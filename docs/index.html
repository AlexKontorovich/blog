<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is the blog of the Lean prover community.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lean community blog</title>
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="assets/css/custom.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css2?family=Merriweather&amp;family=Open+Sans&amp;family=Source+Code+Pro:wght@400;600&amp;display=swap" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="rss.xml">
<link rel="canonical" href="https://leanprover-community.github.io/blog/">
<link rel="icon" href="https://leanprover-community.github.io/img/favicon.ico" sizes="48x48">
<link rel="next" href="index-2.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leanprover-community.github.io/blog/meta-twitter.png">
<meta name="twitter:title" content="Lean community blog">
<link rel="prefetch" href="posts/backstage-with-pechersky/" type="text/html">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="." title="Lean community blog" rel="home">

        <span id="blog-title">Lean community blog</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="https://leanprover-community.github.io/">Main site</a></li>
                <li><a href="archive.html">Archive</a></li>
                <li><a href="categories/">Tags</a></li>
                <li><a href="about/">About</a></li>
                <li><a href="rss.xml">RSS feed</a></li>

    
    
    
    </ul></nav></header><main id="content"><div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/backstage-with-pechersky/" class="u-url">Backstage with Yakov Pechersky</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/johan-commelin/">Johan Commelin</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/backstage-with-pechersky/" rel="bookmark">
            <time class="published dt-published" datetime="2022-01-27T09:35:23+02:00" itemprop="datePublished" title="2022-01-27 09:35">2022-01-27 09:35</time></a>
            </p>
		    <p><span class="text-dark">Interviews</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div>
<p><a href="images/yakov_pechersky.png" class="image-reference"><img src="images/yakov_pechersky.thumbnail.png" class=" align-right"></a></p>
<p>The next installment in the series of
backstage interviews with mathlib's active contributors!</p>
<p>Today, Johan Commelin interviews Yakov Pechersky.
The first half of the interview's video was lost, so it was "recovered"
via written communication.</p>
<p class="more"><a href="posts/backstage-with-pechersky/">Read more…</a></p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2021-the-bottom-line/" class="u-url">2021 - The Bottom Line</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/mathlib-community/">Mathlib community</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/2021-the-bottom-line/" rel="bookmark">
            <time class="published dt-published" datetime="2022-01-08T19:35:59+01:00" itemprop="datePublished" title="2022-01-08 19:35">2022-01-08 19:35</time></a>
            </p>
		    <p><span class="text-dark">overview</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>Since the mathlib repository was created in summer 2017,
each year has been bigger than the last. 
As an end-of-year retrospective, we look at how the mathlib library and community have developed in 2021.</p>
<h2>Statistics</h2>
<p>Since early 2019, mathlib has followed a "squash and merge" strategy for pull requests.
One commit to the main branch corresponds to one merged pull request.</p>
<table>
<thead><tr>
<th></th>
<th>Dec 31, 2020</th>
<th>Dec 31, 2021</th>
<th>Increase</th>
</tr></thead>
<tbody>
<tr>
<td>Number of files</td>
<td>1498</td>
<td>2329</td>
<td>831 (55%)</td>
</tr>
<tr>
<td>Lines of code in repository <sup id="fnref2:1"><a class="footnote-ref" href="posts/2021-the-bottom-line/#fn:1">1</a></sup>
</td>
<td>455152</td>
<td>745259</td>
<td>290107 (64%)</td>
</tr>
<tr>
<td>SLOC in <code>/src</code> <sup id="fnref:1"><a class="footnote-ref" href="posts/2021-the-bottom-line/#fn:1">1</a></sup>
</td>
<td>284441</td>
<td>473644</td>
<td>189203 (67%)</td>
</tr>
<tr>
<td>Lines of comments</td>
<td>65219</td>
<td>108658</td>
<td>43439 (67%)</td>
</tr>
<tr>
<td>Total commits</td>
<td>5751</td>
<td>10960</td>
<td>5209 (91%)</td>
</tr>
<tr>
<td>Definitions</td>
<td>15437</td>
<td>24861</td>
<td>9424 (61%)</td>
</tr>
<tr>
<td>Theorems</td>
<td>44038</td>
<td>72847</td>
<td>28809 (64%)</td>
</tr>
<tr>
<td>Contributors</td>
<td>132</td>
<td>209</td>
<td>77 (58%)</td>
</tr>
</tbody>
</table>
<p>For more information, see the page on <a href="https://leanprover-community.github.io/mathlib_stats.html">mathlib statistics</a>.</p>
<h3>Records</h3>
<p>December 2021 set a record as the month with the highest number of commits, at 565. 
Four of the five most active months happened in 2021;
December, October, and September were mathlib's first, second, and third most active months, respectively.</p>
<p>Yury Kudryashov was the year's most prolific contributor, with 662 commits, surpassing his previous year's record of 624.
Yaël Dillies deserves a special shoutout: 
in their first year of contributing, they became the year's fourth most prolific contributor, with 301 commits.</p>
<h2>New contributors to mathlib</h2>
<p>77 people contributed to mathlib for the first time in 2021.
In total, 864 commits were from new contributors. Many thanks to:</p>
<p>Mohamed Al-Fahim<!-- Github account has been deleted  -->, <a href="https://github.com/Multramate">David Kurniadi Angdinata</a>, <a href="https://github.com/atarnoam">Noam Atar</a>, <a href="https://github.com/MantasBaksys">Mantas Baksys</a>, <a href="https://github.com/itaibn">Itai Bar-Natan</a>, <a href="https://github.com/CBirkbeck">Chris Birkbeck</a>, <a href="https://github.com/manuelcandales">Manuel Candales</a>, <a href="https://github.com/carloscaralps">Carlos Caralps</a>, <a href="https://github.com/robin-carlier">Robin Carlier</a>, <a href="https://github.com/AntoineChambert-Loir">Antoine Chambert-Loir</a>, <a href="https://github.com/peakpoint">Tian Chen</a>, <a href="https://github.com/jchoules">Joanna Choules</a>, <a href="https://github.com/isadofschi">Iván Sadofschi Costa</a>, <a href="https://github.com/saradiazr11">Sara Díaz Real</a>, <a href="https://github.com/YaelDillies">Yaël Dillies</a>, <a href="https://github.com/FrickHazard">Ender Doe</a>, <a href="https://github.com/mcdoll">Moritz Doll</a>, <a href="https://github.com/joneugster">Jon Eugster</a>, <a href="https://github.com/mo271">Moritz Firsching</a>, <a href="https://github.com/Nazgand">Mark Gerads</a>, <a href="https://github.com/SymmetryUnbroken">Vladimir Goryachev</a>, <a href="https://github.com/winestone">Winston Gu</a>, <a href="https://github.com/mguaypaq">Mathieu Guay-Paquet</a>, <a href="https://github.com/vihdzp">Violeta Hernández</a>, <a href="https://github.com/mans0954">Christopher Hoskin</a>, <a href="https://github.com/Jlh18">Joseph Hua</a>, <a href="https://github.com/mariainesdff">María Inés de Frutos-Fernández</a>, <a href="https://github.com/ashwiniyengar">Ashwin Iyengar</a>, <a href="https://github.com/matt-kempster">Matt Kempster</a>, <a href="https://github.com/l-kershaw">Luke Kershaw</a>, <a href="https://github.com/huynhtrankhanh">Huỳnh Trần Khanh</a>, <a href="https://github.com/prakol16">Praneeth Kolichala</a>, <a href="https://github.com/AlexKontorovich">Alex Kontorovich</a>, <a href="https://github.com/kkytola">Kalle Kytölä</a>, <a href="https://github.com/Julian-Kuelshammer">Julian Külshammer</a>, <a href="https://github.com/antoinelab01">Antoine Labelle</a>, <a href="https://github.com/RaitoBezarius">Ryan Lahfa</a>, <a href="https://github.com/Paul-Lez">Paul Lezeau</a>, <a href="https://github.com/j-loreaux">Jireh Loreaux</a>, <a href="https://github.com/berndlosert">Bernd Losert</a>, <a href="https://github.com/GiacomoMaletto">Giacomo Maletto</a>, <a href="https://github.com/thejohncrafter">Julien Marquet</a>, <a href="https://github.com/mmasdeu">Marc Masdeu</a>, <a href="https://github.com/cemulate">Chase Meadors</a>, <a href="https://github.com/yuma-mizuno">Yuma Mizuno</a>, <a href="https://github.com/gabrielmoise">Gabriel Moise</a>, <a href="https://github.com/Sebastian-Monnet">Sebastian Monnet</a>, <a href="https://github.com/hmonroe">Hunter Monroe</a>, <a href="https://github.com/apurvnakade">Apurva Nakade</a>, <a href="https://github.com/AaronGreen001">Anupam Nayak</a>, <a href="https://github.com/apnelson1">Peter Nelson</a>, <a href="https://github.com/lukenels">Luke Nelson</a>, <a href="https://github.com/arthurpaulino">Arthur Paulino</a>, <a href="https://github.com/sorawee">Sorawee Porncharoenwase</a>, <a href="https://github.com/stuart-presnell">Stuart Presnell</a>, <a href="https://github.com/gnprice">Greg Price</a>, <a href="https://github.com/EPronovost">Ethan Pronovost</a>, <a href="https://github.com/javra">Jakob von Raumer</a>, <a href="https://github.com/dwrensha">David Renshaw</a>, <a href="https://github.com/joelriou">Joël Riou</a>, <a href="https://github.com/ericrbg">Eric Rodriguez</a>, <a href="https://github.com/shadasali">Shadman Sakib</a>, <a href="https://github.com/JakobScholbach">Jakob Scholbach</a>, <a href="https://github.com/asouther4">Andrew Souther</a>, <a href="https://github.com/justus-springer">Justus Springer</a>, <a href="https://github.com/frankymacster">François Sunatori</a>, <a href="https://github.com/HenrySwanson">Henry Swanson</a>, <a href="https://github.com/bentoner">Ben Toner</a>, <a href="https://github.com/verberkm">Alain Verberkmoes</a>, <a href="https://github.com/greysome">Way Yan Win</a>, <a href="https://github.com/ineswright">Ines Wright</a>, <a href="https://github.com/erdOne">Andrew Yang</a>, <a href="https://github.com/justadzr">Yourong Zang</a>, <a href="https://github.com/l534zhan">Alex Zhang</a>, <a href="https://github.com/acxxa">Hanting Zhang</a>, <a href="https://github.com/cocohearts">Alex Zhao</a>, <a href="https://github.com/hallow-world"> hallow-world</a></p>
<h2>New mathlib maintainers</h2>
<p>The group of <a href="https://leanprover-community.github.io/meet.html#maintainers">mathlib maintainers</a> has also grown! In 2021, <a href="https://github.com/remydegenne">Rémy Degenne</a>, <a href="https://github.com/TwoFX">Markus Himmel</a>, <a href="https://github.com/b-mehta">Bhavik Mehta</a>, <a href="https://github.com/ocfnash">Oliver Nash</a>, <a href="https://github.com/adamtopaz">Adam Topaz</a>, and <a href="https://github.com/eric-wieser">Eric Wieser</a> joined the team, which now numbers 23. (With the latter three, the team finally includes surnames from the second half of the alphabet.)</p>
<h2>New field in mathlib: probability theory</h2>
<p>The measure theory and analysis libraries have been developed enough to allow the definition of some probability theory concepts. mathlib now contains definitions of independence, probability density functions, conditional expectations, martingales and stopping times. We don't have many theorems about them yet and many other basic definitions are still missing, but the foundations are in place and 2022 should see a large development of probability theory in mathlib.</p>
<h2>New Lean 3 community releases</h2>
<p>The community has continued to maintain its version of Lean 3. Lean 3.24.0c was released Jan 4, 2021; as of Dec 31, the current version was 3.35.1c. Changes include:</p>
<ul>
<li>Parts of the core library were transitioned to mathlib to ease maintenance.</li>
<li>Features were changed to support the transition to Lean 4, including coercion handling, <code>ite</code>/<code>dite</code>, and export formats.</li>
<li>Many bugs were squashed, much documentation was added.</li>
</ul>
<p>The Lean 3 repository includes a <a href="https://github.com/leanprover-community/lean/blob/master/doc/changes.md">full change log</a>.</p>
<h2>Hoskinson Center for Formal Mathematics</h2>
<p>In <a href="https://leanprover-community.github.io/blog/posts/hoskinson-center-announced/">September</a>,
Carnegie Mellon University <a href="https://www.cmu.edu/news/stories/archives/2021/september/hoskinson-center-for-formal-mathematics.html">announced</a> that 
a $20 million gift from blockchain entrepreneur Charles C. Hoskinson 
will be used to establish the Hoskinson Center for Formal Mathematics, 
housed in the Department of Philosophy. 
The center supports work making formal mathematics accessible and enjoyable to as wide an audience as possible.</p>
<h2>Lean Together 2021</h2>
<p>Way back in January, we hosted <a href="https://leanprover-community.github.io/lt2021/">Lean Together 2021</a>, 
an online meeting for Lean users and people from other formalization communities. 
The meeting included a number of talks, 
all <a href="https://www.youtube.com/playlist?list=PLlF-CfQhukNnO8z3TcFcoKozif9gbl7Yt">recorded and posted on YouTube</a>,
as well as informal discussions and social time. 
Some highlights: Leonardo de Moura and Sebastian Ullrich <a href="https://www.youtube.com/watch?v=UeGvhfW1v9M&amp;list=PLlF-CfQhukNnO8z3TcFcoKozif9gbl7Yt&amp;index=5&amp;ab_channel=leanprovercommunity">officially introduced Lean 4</a>,
and a number of panelists discussed <a href="https://www.youtube.com/watch?v=mTLuON5eRZI&amp;list=PLlF-CfQhukNnO8z3TcFcoKozif9gbl7Yt&amp;index=23&amp;t=6s&amp;ab_channel=leanprovercommunity">using proof assistants in the classroom</a>. </p>
<h2>Big projects</h2>
<h3>Liquid Tensor Experiment</h3>
<p>One of the spectacular highlights in 2021 was the formalization of Theorem 9.4 of Scholze's 
<a href="https://www.math.uni-bonn.de/people/scholze/Analytic.pdf">Lectures on Analytic Geometry</a>. This
is the main technical ingredient in the proof of the main theorem of
liquid vector spaces, a recent result of Clausen and Scholze. We embarked
on this project after Scholze posted
a <a href="https://xenaproject.wordpress.com/2020/12/05/liquid-tensor-experiment/">challenge</a>
to the formalization communities.</p>
<p>We reached the milestone within half a year, faster than anyone had expected,
surprising ourselves and others.
The accomplishment was covered by
<a href="https://www.nature.com/articles/d41586-021-01627-2">Nature</a>
and
<a href="https://www.quantamagazine.org/lean-computer-program-confirms-peter-scholze-proof-20210728/">Quanta</a>.</p>
<p>The full challenge is not yet completed,
and is actively worked on right now.
See one of our recent blogposts for a
<a href="https://leanprover-community.github.io/blog/posts/lte-update/">progress report</a>.</p>
<h3>Sphere eversion</h3>
<p>The 
<a href="https://leanprover-community.github.io/sphere-eversion/">sphere eversion project</a> 
aims to formalize flexibility results in differential topology, including
the celebrated existence of sphere eversions in $ℝ^3$. Development really
took off in September 2021 with Floris van Doorn and Oliver Nash joining
Patrick Massot in the project, with some extra help from Anatone Dedecker.</p>
<p>All the affine geometry of the project is now done, thanks to the work of
Oliver, which was mostly contributed directly to mathlib. Most of general
topology entering the project has been done, with Floris proving some
delicate continuous function gluing results, and currently finishing some
covering lemmas. The calculus backbone has been worked out by Patrick who
proved many results about continuity and differentiability of integrals
depending on parameters (still to be fully brought to mathlib) with help
from Floris. Using this, the fundamental corrugation estimates have been
proved. The project is now ready to merge those three aspects (affine
geometry, topology and calculus) to prove all local results. Then the
final part will be to handle the global theory using the differentiable
manifolds theory in mathlib.</p>
<h3>Fermat's Last Theorem for regular primes</h3>
<p>The aim of the <a href="https://github.com/leanprover-community/flt-regular">flt-regular project</a>
is to prove Fermat's Last Theorem for
<a href="https://en.wikipedia.org/wiki/Regular_prime">regular primes</a>,
an important result proved in 1850.
This project continues the development of
<a href="https://leanprover-community.github.io/blog/posts/dedekind-domains-and-class-number-in-lean/">algebraic number theory</a> in mathlib.
You can have a look at the <a href="https://leanprover-community.github.io/flt-regular/">blueprint</a> to check the mathematical details.
After having developed the basic properties of cyclotomic extensions and of the discriminant,
we are now computing the ring of integers of a cyclotomic extension.
We can then work in $\mathbb{Z}[\zeta_p]$:
doing arithmetic in $\mathbb{Z}[\zeta_p]$ is more complicated than in $\mathbb{Z}$,
but the regularity assumption allows to prove the results we need.</p>
<h3>Lean 4 porting effort</h3>
<p>An early version of Lean 4 was released on Jan 4, 2021. 
Since then, effort has been going into tooling to help port mathlib from Lean 3.
The <a href="https://github.com/leanprover-community/mathlib4"><code>mathlib4</code> library stub</a>
and <a href="https://github.com/leanprover-community/mathport"><code>mathport</code> tool</a>
are both ongoing projects.</p>
<p>A <a href="https://leanprover-community.github.io/blog/posts/intro-to-mathport/">recent blog post</a>
describes the current state of the effort.</p>
<h2>Monthly recaps</h2>
<p>Since the creation of this blog in summer 2021 we have recapped the project activity each month.</p>
<ul>
<li><a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-aug-2021/">August</a></li>
<li><a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-sep-2021/">September</a></li>
<li><a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-oct-2021/">Octover</a></li>
<li><a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-nov-2021/">November</a></li>
<li><a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-dec-2021/">December</a></li>
</ul>
<h2>Looking forward</h2>
<p>A lot has changed in 2021. What's to come in 2022? 
Nobody knows for sure, but there's plenty to look forward to!
Come <a href="https://leanprover.zulipchat.com">join the crowd</a> 
and help make this year an even bigger one than the last.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>We count source lines of code using <a href="http://cloc.sourceforge.net/"><code>cloc</code></a>. This count includes only non-comment, non-whitespace lines of Lean code in the <code>/src</code> directory of mathlib. The "lines of code in repository" count includes blank and comment lines in all file types in all directories of the mathlib repository. <a class="footnote-backref" href="posts/2021-the-bottom-line/#fnref:1" title="Jump back to footnote 1 in the text">↩</a><a class="footnote-backref" href="posts/2021-the-bottom-line/#fnref2:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/month-in-mathlib-dec-2021/" class="u-url">This month in mathlib (Dec 2021)</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/mathlib-community/">Mathlib community</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/month-in-mathlib-dec-2021/" rel="bookmark">
            <time class="published dt-published" datetime="2022-01-01T12:13:11+01:00" itemprop="datePublished" title="2022-01-01 12:13">2022-01-01 12:13</time></a>
            </p>
		    <p><span class="text-dark">month-in-mathlib</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>December 2021 saw 565 commits to mathlib, which sets a new record.
In this post we highlight some of these contributions.</p>
<ul>
<li>Combinatorics.<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10287">PR #10287</a> defines graph colorings and partitions.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10981">PR #10981</a> defines the concepts of walks, paths, cycles in graph theory.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10509">PR #10509</a> defines <a href="https://en.wikipedia.org/wiki/Salem%E2%80%93Spencer_set">Salem-Spencer sets</a> and Roth numbers.</li>
</ul>
</li>
<li>Commutative algebra.<ul>
<li>There is now a systematic way to talk about local properties of rings and
  ring homomorphisms.
  <a href="https://github.com/leanprover-community/mathlib/pull/10734">PR #10734</a> and
  <a href="https://github.com/leanprover-community/mathlib/pull/10775">PR #10775</a>
  prove
  that being reduced, finite or of finite type are local properties.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9888">PR #9888</a>
  does not introduce new mathematics, but introduces a new way that makes
  it exceedingly easy to apply lemmas about group homomorphisms to a ring
  homomorphism (or a linear map, or an algebra homomorphism, etc).</li>
</ul>
</li>
<li>Algebraic topology.<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9762">PR #9762</a>
  defines simplicial complexes embedded in an ambient vector space or more generally in a module over an ordered ring.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10927">PR #10927</a>
  defines the alternating face map complex of a simplicial object.</li>
</ul>
</li>
<li>Geometry<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10733">PR #10733</a>
  shows that an integral scheme is reduced and irreducible.
  That a scheme is reduced iff its stalks are reduced is shown in
  <a href="https://github.com/leanprover-community/mathlib/pull/10879">PR #10879</a>.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/8611">PR #8611</a> defines the action of <code>SL(2, ℤ)</code> on the upper half plane and partially classifies its orbits.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10306">PR #10306</a> defines
  orientations of modules and rays in modules. This will be useful in particular in order to define oriented angles in Euclidean plane geometry.</li>
</ul>
</li>
<li>General topology <ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10967">PR #10967</a>
  defines uniform convergence on compact subsets for maps from a topological space to a uniform space (for instance a metric space or a topological group). It also shows that the underlying
  topology is the compact-open topology.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10914">PR #10914</a>
  introduces the specialization order for topological spaces
  as well as the notion of generic points and sober spaces. Then 
  <a href="https://github.com/leanprover-community/mathlib/pull/10989">PR #10989</a> and
  <a href="https://github.com/leanprover-community/mathlib/pull/11040">PR #11040</a>
  show that schemes are sober.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10701">PR #10701</a>
  proves the <a href="https://en.wikipedia.org/wiki/Tietze_extension_theorem">Tietze extension theorem</a>.</li>
</ul>
</li>
<li>Functional analysis<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10825">PR #10825</a> defines the adjoint of a continuous linear map between Hilbert spaces, made possible by the <a href="https://leanprover-community.github.io/blog/posts/semilinear-maps">semilinear map refactor</a>, and <a href="https://github.com/leanprover-community/mathlib/pull/10837">PR #10837</a> uses this to put a $C^\ast$-algebra structure on the continuous linear maps on a Hilbert space.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10322">PR #10322</a> proves continuous bounded real-valued functions form a normed vector lattice.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10663">PR #10663</a>
  proves the <a href="https://en.wikipedia.org/wiki/Uniform_boundedness_principle">Banach-Steinhaus theorem</a>.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9836">PR #9836</a> adds polar sets in preparation for the Banach-Alaoglu theorem.</li>
</ul>
</li>
<li>Measure theory, integration and probability<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/11035">PR #11035</a>
  proves one can cover a set in a real vector by balls with controlled
  measure. This continues the preparation for differentiation of measures.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10906">PR #10906</a>
  define integration on circles in the complex plane. This is foundational
  material for complex analysis. Important applications will follow very
  soon.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10625">PR #10625</a> defines martingales, and <a href="https://github.com/leanprover-community/mathlib/pull/10710">PR #10710</a> adds super/sub-martingales.</li>
</ul>
</li>
</ul>
</div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/lte-update/" class="u-url">Liquid Tensor Experiment: an update</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/johan-commelin/">Johan Commelin</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/lte-update/" rel="bookmark">
            <time class="published dt-published" datetime="2021-12-31T21:04:21+02:00" itemprop="datePublished" title="2021-12-31 21:04">2021-12-31 21:04</time></a>
            </p>
		    <p><span class="text-dark">Community projects</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>In June 2021, we <a href="https://xenaproject.wordpress.com/2021/06/05/half-a-year-of-the-liquid-tensor-experiment-amazing-developments/">celebrated</a>
the first milestone of the Liquid Tensor Experiment.
The achievement was covered in
<a href="https://www.nature.com/articles/d41586-021-01627-2">Nature</a>
and
<a href="https://www.quantamagazine.org/lean-computer-program-confirms-peter-scholze-proof-20210728/">Quanta</a>.
Since then, we haven't been sitting still, and it's high time for a status update.</p>
<p>The first milestone was a proof of the following
<a href="https://github.com/leanprover-community/lean-liquid/blob/b94b4bf4c9a60aa72bc226d0ee4218f8ef9e6049/src/liquid.lean#L37">statement</a></p>
<pre class="code literal-block"><span class="sd">/-- A mix of Theorems 9.4 and 9.5 in [Analytic] -/</span>
<span class="kd">theorem</span> <span class="n">first_target</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="n">K</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">c₀</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">SemiNormedGroup.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="o">[</span><span class="n">normed_with_aut</span> <span class="n">r</span> <span class="n">V</span><span class="o">],</span>
    <span class="o">((</span><span class="n">BD.data.system</span> <span class="n">κ</span> <span class="n">r</span> <span class="n">V</span> <span class="n">r'</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="bp">$</span> <span class="n">of</span> <span class="n">r'</span> <span class="o">(</span><span class="n">Mbar</span> <span class="n">r'</span> <span class="n">S</span><span class="o">)))</span><span class="bp">.</span><span class="n">is_weak_bounded_exact</span> <span class="n">k</span> <span class="n">K</span> <span class="n">m</span> <span class="n">c₀</span> <span class="o">:=</span>
</pre>
<p>This says that a certain system of complexes <code>(BD.data.system κ r V r').obj (op $ of r' (Mbar r' S))</code>
satisfies the technical condition of weak bounded exactness with respect to certain parameters.
This system of complexes fundamentally depends on a semi-normed group <code>V</code>
and a certain space <code>Mbar r' S</code>.
We will say a bit more about this mysterious object <code>Mbar r' S</code> later.</p>
<p>To complete the final challenge,
we need to remove the <code>sorry</code> from the following
<a href="https://github.com/leanprover-community/lean-liquid/blob/b94b4bf4c9a60aa72bc226d0ee4218f8ef9e6049/src/challenge.lean#L27">statement</a></p>
<pre class="code literal-block"><span class="kd">variables</span> <span class="o">(</span><span class="n">p'</span> <span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">p'</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">p'</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">p'</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">p</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)]</span>

<span class="kd">theorem</span> <span class="n">liquid_tensor_experiment</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Profinite.</span><span class="o">{</span><span class="mi">1</span><span class="o">})</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">pBanach.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Ext</span> <span class="n">i</span> <span class="o">(</span><span class="n">ℳ_</span><span class="o">{</span><span class="n">p'</span><span class="o">}</span> <span class="n">S</span><span class="o">)</span> <span class="n">V</span> <span class="bp">≅</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre>
<p>In this statement, <code>ℳ_{p'} S</code> is morally a space of real-valued measures depending on the real parameter <code>p'</code>
and the <code>p</code>-Banach space <code>V</code> is an example of the semi-normed groups showing up in <code>first_target</code> above.
But the <code>Ext</code> in this statement is really about the Ext-groups of condensed abelian groups,
so both <code>ℳ_{p'} S</code> and <code>V</code> are viewed as condensed abelian groups in this theorem.</p>
<h2>Homological algebra</h2>
<p>To be able to state this theorem (e.g., to make sense of <code>Ext</code>)
we need to develop the theory of derived functors
for arbitrary abelian categories with enough injectives/projectives.
This was done by Scott Morrison, who contributed definitions of <code>Ext</code> and <code>Tor</code> to mathlib about half a year ago.
We also need to show that the category of condensed abelian groups satisfies these conditions.
Recently, Adam Topaz finished a formalization of the fact that on an arbitrary site (= category + Grothendieck topology)
the category of sheaves with values in a suitable abelian category is itself an abelian category.
In particular the category of abelian sheaves, and hence the category of condensed abelian groups, is an abelian category.
The fact that condensed abelian groups have enough projectives is almost done,
so that finally the <code>Ext</code> in the statement above does no longer depend on unformalized assumptions.</p>
<p>To be able to compute the <code>Ext</code>-groups,
we need a library of results about homological complexes, long exact sequences, and such.
A fundamental input is of course the snake lemma,
and this was formalized by Riccardo Brasca and Adam Topaz in the fall.
Andrew Yang is currently working towards a formal proof
that the homotopy category of complexes is a pretriangulated category.
This will give us important tools to manipulate the <code>Ext</code>-groups
into a shape that reduces to <code>first_target</code>.</p>
<h2>Spaces of measures</h2>
<p>As mentioned above, the space <code>ℳ_{p'} S</code> is a real condensed vector space
that is morally a space of measures.
One of the crucial insights in the proof is that it is a quotient of an arithmetic analogue
that we've been calling the space of <em>Laurent measures</em>: <code>ℳ(S, ℤ((T))_{r'})</code>,
with <code>(1/2)^{p'} = r'</code>.
This quotient map turns out to be the cokernel of an injective endomorphism of the space of Laurent measures.
Together, these two maps form a short exact sequence,
which leads to a long exact sequence of <code>Ext</code>-groups.
Hence the vanishing of the <code>Ext</code>-groups above can be reduced to a question about similar <code>Ext</code>-groups
but this time involving these spaces of Laurent measures.</p>
<p>In turn, these spaces of Laurent measures naturally admit a free module as submodule,
and the quotient is the mysterious space <code>Mbar r' S</code> that appears in <code>first_target</code>.
Together, these two short exact sequences are crucial inputs
that will be combined with the homological tools mentioned above
to reduce the main theorem to <code>first_target</code>.</p>
<p>Filippo A.E. Nuccio has been working arduously on the formalization of these results,
which amount to Theorem 6.9 of <a href="https://www.math.uni-bonn.de/people/scholze/Analytic.pdf">Analytic.pdf</a>.</p>
<h2>Breen–Deligne resolutions and MacLane's Q'-construction</h2>
<p>Finally, to compute the <code>Ext</code>-groups, at some point projective resolutions must enter the picture.
The proof in <a href="https://www.math.uni-bonn.de/people/scholze/Analytic.pdf">Analytic.pdf</a>
relies on so-called Breen–Deligne resolutions, which have the following two crucial properties:</p>
<ol>
<li>It is a functorial construction <code>A ↦ C(A)</code> that sends an abelian group (or sheaf) to a complex of abelian groups (or sheaves).</li>
<li>When viewed as a functor to the homotopy category of complexes, it is additive.
  In other words, <code>C(A ⊕ A)</code> is naturally homotopic to <code>C(A) ⊕ C(A)</code>.</li>
</ol>
<p>In addition to these properties,
Breen–Deligne resolutions have the favourable property that the construction yields a projective resolution <code>C(A)</code> for every <code>A</code>.</p>
<p>For our formalization project, they also come with the significant downside that the proof of the existence of Breen–Deligne resolutions
relies on technical results from homotopy theory,
which haven't been formalized yet.</p>
<p>But to our delight, it turns out that there are related constructions that satisfy (1) and (2) above which are good enough for our purposes and which can be formalized directly.
Indeed, the functorial complex known as "MacLane's <code>Q'</code> construction", is one such example.
On top of that, the following result holds.</p>
<p><strong>Lemma.</strong> Let $A$ and $B$ be two abelian groups (or sheaves).
If $\text{Ext}^i(Q'(A), B) = 0$ for all $i \ge 0$,
then $\text{Ext}^i(A, B) = 0$ for all $i \ge 0$.</p>
<p>This lemma is not yet formalized,
and to our knowledge it does not appear in the literature.
We hope to fix both of these issues in the near future.</p>
<p>So far, we have formalized the claim that the <code>Q'</code>-construction satisfies properties (1) and (2).
The proof of the lemma uses the tensor-hom adjunction and the fact that the homotopy category of complexes is pretriangulated.
The formalisation of these two prerequisites is active work in progress.</p>
<p>You can follow our progress on all the remaining tasks at the following
<a href="https://github.com/leanprover-community/lean-liquid/projects/2">Github project</a>.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/intro-to-mathport/" class="u-url">Update on mathport (Dec 2021)</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/scott-morrison/">Scott Morrison</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/intro-to-mathport/" rel="bookmark">
            <time class="published dt-published" datetime="2021-12-22T12:41:00+01:00" itemprop="datePublished" title="2021-12-22 12:41">2021-12-22 12:41</time></a>
            </p>
		    <p><span class="text-dark">mathport</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p><code>mathport</code> is the tool we're planning on using to help us port <code>mathlib</code> to Lean 4.
It has mostly been written by Mario Carneiro and Daniel Selsam,
and Gabriel Ebner and I have been making some fixes.</p>
<p>To provide some context, <a href="https://github.com/leanprover-community/mathlib">mathlib</a>
is the primary library for mathematics in Lean 3,
containing over 700k lines of code and growing fast!
Lean 4 now has a preliminary release, and we would really like to transition to
building a mathematics library in Lean 4.
While the type theory and kernel in Lean 4 are quite similar from a user point of view to Lean 3,
it is certainly not the case that we can run Lean 3 code in Lean 4.
Our aspiration is to achieve a "semi-automated" port.</p>
<p>The <code>mathport</code> tool first of all provides a complete binary level port of <code>mathlib</code>
(i.e. generating a Lean 4 <code>.olean</code> file for every <code>.olean</code> file in <code>mathlib</code>).
This means that you will be able to <code>import</code> all files from <code>mathlib</code>,
as long as you don't expect to be able to look at the actual sources!
We have largely rejected the idea of a dual-compilation setup,
in which existing code stays in Lean 3, while new code is written in Lean 4.
The binary port could make this viable, but it seems complicated and fragile,
and the community is excited to take full advantage of Lean 4.
(A dual-compilation setup would not allow Lean 3 files to import from Lean 4 files,
so the version transition would have to be a cut across the import graph.)
Thus <code>mathport</code> further attempts a "best-effort" port of the source files,
translating Lean 3 syntax to Lean 4 syntax.
Right now, that "best effort" is not quite good enough!</p>
<p>Our goal is that this will steadily improve,
until we reach a point at which it become viable for humans
to finish the migration in an incremental fashion.
Notably, because of the size of <code>mathlib</code>, and its growth rate,
we have decided it is not desirable to "freeze" <code>mathlib3</code>
until very late in the process.
(Throughout this document, <code>mathlib</code> refers to the current mathlib repository,
but I'll try to consistently include the <code>3</code> to disambiguate!)
Thus we will be regularly running <code>mathport</code> on a continuously evolving <code>mathlib3</code> repository,
and for an initial period not depositing the output in the <code>mathlib4</code> repository.
Nevertheless, <code>mathport</code> takes as input both <code>mathlib3</code> and <code>mathlib4</code>,
and attempts to automatically make use of the parts of the library which have already been ported,
by "aligning" definitions.
Thus once the output quality of <code>mathport</code> is sufficiently good,
we expect to be able to move files across to the <code>mathlib4</code> repository
(starting from the bottom of the import hierarchy),
while continuing to re-run <code>mathport</code> on the still evolving <code>mathlib</code> repository!
Eventually, however, we will declare "flag day",
at which point the <code>mathlib3</code> repository will stop accepting PRs for new material,
and we have a (hopefully brief!) intensive period of completing the migration.</p>
<p>Notably, <code>mathport</code> makes no attempt to automatically translate the tactics that have been written in <code>mathlib3</code>.
Metaprogramming is sufficiently different in Lean 4 that this would be impossible,
and moreover there are significant stylistic differences when writing tactics in Lean 4,
so a literal translation would not be desirable.
This means that we have a huge amount of work remaining to re-implement all the <code>mathlib3</code> tactics in Lean 4.
We've already done a few important ones (notably <code>simp</code> is implemented in Lean 4, and we have <code>ring</code> in <code>mathlib4</code>).
We would really like to preserve feature parity as we make the transition,
and so are hoping to re-implement tactics, rather than "dumb-down proofs" wherever possible.</p>
<p>The occasion for this blog post is that we now have continuous integration set up for <code>mathport</code>,
and a reasonably easy to use setup that lets you work with the output of <code>mathport</code>
without having to run it yourself.</p>
<p>I'll describe that setup up below, but first explain what sort of efforts are probably most useful right now to help the <code>mathlib</code> port.</p>
<p>They are approximately in priority order, in terms of my guess about what will hold up the port the most.</p>
<ul>
<li>Porting missing tactics from <code>mathlib3</code> to <code>mathlib4</code>.
  This is still a huge task, and will not be automated in any way.
  If you've contributed tactics to <code>mathlib3</code>, please consider trying to port them to Lean 4.
  If you're interested in learning some Lean 4 metaprogramming, what better way to do that than porting tactics?
  We'll write more about this in a future post, with some pointers about places to get started,
  and how to hook up new tactic implementations to the existing tactic parsers that Mario has already ported to <code>mathlib4</code>.</li>
<li>Resolve outstanding <a href="https://github.com/leanprover-community/mathport/issues">issues</a> in <code>mathport</code>.
  (On some issues there's already an indicated fix but it needs implementing/testing.
  Other issues still need diagnosis.)</li>
<li>Open the <code>mathlib3port</code> repository (instructions below), look at files (probably starting with "low-level" files),
  and identify things that <code>mathport</code> should be doing better. Check there isn't already an open issue, then open an issue.<ul>
<li>Note: at this stage I think it would be a bad idea to actually take a file from <code>mathlib3port</code>, clean it up, and PR it to <code>mathlib4</code>.
  That will hopefully come later, but we need to fix many <code>mathport</code> issues first.</li>
<li>Instead, it is fine to make changes <em>that you think <code>mathport</code> should be doing already</em> and committing these on a branch,
  so that you can link to diffs when opening <code>mathport</code> issues.</li>
<li>For now, don't worry too much about the state of proofs.
  We'd like to get to a state where the vast majority of <em>statements</em> are correctly translated as soon as possible.</li>
<li>There are still many alignment problems between Lean 3 / <code>mathlib3</code> declarations, and Lean 4 / <code>mathlib4</code> declarations.
  Sometimes these can be fixed by adding <code>#align</code> commands in <code>mathlib4</code>. Sometimes they may turn out to be <code>mathport</code> bugs.
  Sometimes they will reflect deeper design problems we're going to need to talk about!</li>
</ul>
</li>
</ul>
<h2>Background: what is <code>mathport</code>?</h2>
<p><code>mathport</code> consists of two loosely coupled components: <code>binport</code> (largely Daniel's work), and <code>synport</code> (largely Mario's work).</p>
<ul>
<li>
<p><code>binport</code> constructs Lean 4 <code>.olean</code> files, from Lean 3 <code>.olean</code> files.
    It largely works, and means that you can import <code>mathlib3</code> content into Lean
    4 (as long as you don't expect to have source files!)
    This is what lets us do things like: </p>
<pre class="code literal-block"><span class="kn">import</span> <span class="nn">Mathbin</span>

<span class="c1">#lookup3 algebraic_geometry.Scheme</span>
<span class="c1">#check AlgebraicGeometry.Scheme</span>
</pre>
<p>Yay, Lean 4 has schemes! :-)
To see this file in action, you should check out a copy of the <code>mathlib3port</code> repository described below,
and make a new file there.</p>
</li>
<li>
<p><code>synport</code> constructs Lean 4 <code>.lean</code> files, on a "best effort" basis.
  (It uses both the output from binport, and Lean 3's <code>--ast</code> output to guide it.)
  We should not expect that this will ever converge to a perfect translator.
  Instead the hope is that it gives us something that humans can plausibly improve to a complete translation of <code>mathlib3</code>.</p>
</li>
</ul>
<p>To understand how <code>mathport</code> (mostly talking about the synport part from here on) works,
it's important to understand that it is translating <code>mathlib3</code> to Lean 4 source code, "modulo" the current content of <code>mathlib4</code>.
That is, the premise is that as we progressively construct <code>mathlib4</code>
(whether by translating by hand, moving content from <code>mathport</code>'s output to <code>mathlib4</code>, or adding <code>#align</code> statements)
the output from running <code>mathport</code> on <code>mathlib3</code> will change.
In particular, as <code>mathport</code> is translating each declaration,
it checks to see if a corresponding declaration in <code>mathlib4</code> already exists, and is defeq.
If so, <code>mathport</code> will instead just use that declaration.
If not, <code>mathport</code> will make a copy, appending a <code>×</code> to the name.
Sometimes these misalignments are due to an unintentional non-defeq, that can be fixed in <code>mathlib4</code>.
Other times, we genuinely want to change something in <code>mathlib4</code>
(e.g. to use Lean 4's multiple parent structures, which are better than <code>old_structure_cmd</code>).
As a result, we expect that some misalignments will persist throughout the <code>mathport</code>-assisted stage of the port,
and only afterwards will we polish these away.</p>
<p>A detailed account of how binport and synport are working is beyond the scope of this blog post.
Hopefully we'll have one eventually,
but in the meantime <a href="https://www.youtube.com/watch?v=fOO2fByx8tw">Mario's talk</a> is very helpful.</p>
<h2>What should I look at?</h2>
<p>Please note that <code>mathport</code> takes considerable resources to run on <code>mathlib3</code>: approximately 3.5 hours, and 32gb of RAM.
So you'll probably want to look at artifacts generated by CI rather than running it yourself. There are four GitHub repositories you can look at:</p>
<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib3port">mathlib3port</a>
  should be most people's first stop. This contains a copy of the <code>.lean</code>
  files produced by a recent run of <code>synport</code>, in the <code>Mathbin</code> directory.
  You should just be able to check out a copy of this repository, and open
  the folder in VS Code, to see the current state of <code>mathport</code> output.
  You can also try out the above example with <code>#check
  AlgebraicGeometry.Scheme</code> in a fresh file here.<ul>
<li>Remember the synported files are expected to be horribly broken;
  most tactics aren't implemented, and there are bugs around
  parenthesization of arguments, and name resolution!</li>
<li>Good luck finding even a single file that compiles cleanly right now.</li>
</ul>
</li>
<li>
<a href="https://github.com/leanprover-community/lean3port">lean3port</a> is the corresponding repository
  containing a copy of a recent run of <code>mathport</code> on the Lean 3 core library.
  It's less interesting perhaps, but also smaller and easier to inspect.</li>
<li>
<a href="https://github.com/leanprover-community/mathport">mathport</a> contains the code for <code>mathport</code> itself,
  as well as the continuous integration set up that runs <code>mathport</code> on Lean 3 core and <code>mathlib3</code>
  every time there is either a PR to <code>mathport</code>, or a commit to master.
  The artifacts produced by CI appear at https://github.com/leanprover-community/mathport/releases,
  and the two repositories listed above have a <code>lakefile.lean</code> that will download and unpack these artifacts.</li>
<li>
<p><a href="https://github.com/leanprover-community/mathlib4">mathlib4</a> is the current preliminary port of <code>mathlib</code> to Lean 4.
  Later, when <code>mathport</code> begins to stabilize,
  we will begin moving files from the output of <code>mathport</code> into this repository, but not yet.
  For now, this repository serves several purposes:</p>
<ul>
<li>Primarily, it is the home for ports of tactics implemented in <code>mathlib3</code> to Lean 4.</li>
<li>In order to build these tactics, a certain minimal library is necessary
  (e.g. for the <code>ring</code> tactic, we need the notion of a <code>ring</code>!)
  and we are constructing this by hand.</li>
<li>There is scope for experimental developments,
  but please don't just port parts of <code>mathlib3</code> to Lean 4
  for the sake of doing so.
  If you're investigating how some new Lean 4 feature might be used in the eventual port of <code>mathlib</code>,
  it's okay to do so in this repository.</li>
</ul>
<p>For now, the <code>mathlib4</code> repository has fairly low standards:
we don't expect the full review process used in <code>mathlib3</code>.
Notable parts of the <code>mathlib4</code> repository relevant for <code>mathport</code> are:</p>
<ul>
<li>
<code>Mathlib/Mathport/SpecialNames.lean</code> contains a sequence of <code>#align</code> statements,
  for cases where a definition in Lean 4 core has a different name
  from the name that would be produced automatically by changing case conventions from Lean 4 or <code>mathlib3</code>.</li>
<li>
<code>Mathlib/Mathport/Syntax.lean</code> contains definitions of all the syntaxes of tactics currently implemented in <code>mathlib3</code>.
  These have been written by hand by Mario, and we should take care to keep these up to date.
  Please be careful editing this file,
  and we also need to remember to update it if any further changes to tactics land in <code>mathlib3</code>.
  Because in this file we only have the syntax statements,
  if you try to use the tactics here you will get <code>Tactic not implemented yet</code> errors.
  If you would like to work on porting tactics, essentially this file is the TODO list!
  You should take the relevant syntax definitions,
  move them to their own file in the <code>Mathlib/Tactic/</code> directory,
  and provide an implementation.
  Conversely, please do not start porting a <code>mathlib3</code> tactic without faithfully reproducing the syntax,
  as this will then cause problems for <code>mathport</code>.
  It's completely fine to provide an interim port, that throws errors when encountering
  some of the bells and whistles specified by a syntax declaration.</li>
</ul>
</li>
</ul>
<h2>How do I run <code>mathport</code>?</h2>
<p>The <code>Makefile</code> in https://github.com/leanprover-community/mathport is currently the best available documentation for running <code>mathport</code>.
You will need to make sure you have <code>curl</code>, <code>git</code>, <code>cmake</code>, and <code>elan</code> installed on your system.
Basic usage is <code>make build source predata port</code>.</p>
<p>These stages are:</p>
<ul>
<li>
<code>build</code>: compile <code>mathport</code> (which is written in Lean 4) itself</li>
<li>
<code>source</code>: pull the relevant commits of Lean 3 and <code>mathlib3</code>, and do a little preparatory work in those directories</li>
<li>
<code>predata</code>: recompile the Lean 3 library and <code>mathlib3</code>, with <code>lean --ast --tlean</code>, to generate the auxiliary files <code>mathport</code> needs.</li>
<li>
<code>port</code>: run <code>mathport</code> on Lean 3 and <code>mathlib3</code>.</li>
</ul>
<p>Running all of them in sequence is necessary if you're starting from scratch, but is painfully slow.</p>
<p>You don't really want to run <code>make predata</code> yourself.
Typically you don't want to run <code>make port</code> on the entire library either: you'd prefer to download an artifact containing the results,
but then re-run <code>mathport</code> on a single file, in order to try out a bugfix to <code>mathport</code>.</p>
<p>We provide artifacts for various stages of the build on the releases page of the <code>mathport</code> repository.
The script <code>./download-release.sh nightly-YYYY-MM-DD</code> downloads one of these,
after which you can skip the <code>make predata</code> and/or <code>make port</code> steps
(you will still need to run <code>make build</code> and <code>make source</code>).</p>
<p>If you've already got a local copy of the output of <code>make port</code> (either by running it yourself, or using <code>./download-release.sh</code>)
you can also use the <code>make TARGET=data.nat.bitwise port-mathbin-single</code> target
(similarly for <code>port-lean-single</code>) to run <code>mathport</code> on a single file.
This is useful if you are testing a change to <code>mathport</code>.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/backstage-with-dillies/" class="u-url">Backstage with Yaël Dillies</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/johan-commelin/">Johan Commelin</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/backstage-with-dillies/" rel="bookmark">
            <time class="published dt-published" datetime="2021-12-17T09:35:23+02:00" itemprop="datePublished" title="2021-12-17 09:35">2021-12-17 09:35</time></a>
            </p>
		    <p><span class="text-dark">Interviews</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p><a href="images/yael_dillies.jpg" class="image-reference"><img src="images/yael_dillies.thumbnail.jpg" class=" align-right"></a></p>
<p>We're introducing a new category of blog post:
backstage interviews with mathlib's active contributors!</p>
<p>Today, Johan Commelin interviews Yaël Dillies.</p>
<p><strong>JMC: Please tell us a bit about yourself, about your background.</strong></p>
<p>YD: Hi! I am Yaël Dillies.
I was brought up in France, in Nantes. That's in the west, near the coast.
I've basically lived there all my life, and went to school there.
My first memorable contact with maths was via the Kangaroo math competition,
when I was 13 or 14 years old.
I became 3rd out of 25000 participants,
and was invited to an olympic math camp.
That got me hooked, and I certainly learned a lot there.
It was a really nice environment,
and the competitions pushed me forward into mathematics.</p>
<p>After high school I had to decide:
either I would stay in the French system
which meant going to <em>prépa</em>
[JMC: two years of preparation for the <em>grandes écoles</em> in France]
which is very intense.
Also, part of what they do there is not math,
but I knew that I was into math, and that's what I wanted to do.
Instead, I decided to go to Cambridge.
That's where I am now, in my second year of studies.</p>
<p><strong>JMC: How did you first learn about Lean? How did you get involved?</strong></p>
<p>YD: Leanwise, it all started with Kevin's [JMC: Kevin Buzzard] talk last February
that he gave for the Archimedeans in Cambridge.
I had already heard about Lean at that point,
from the <a href="https://chalkdustmagazine.com/features/can-computers-prove-theorems/">chalkdust article</a>,
from which I understood that it was some game that you can play.
That made me wonder: "Who is making the levels? What is the end goal?"</p>
<p>JMC: Wow, so in a couple of months you went from beginner to expert contributor!</p>
<p>YD: [Chuckles] If you say so.</p>
<p>JMC: Did you have prior experience with programming?</p>
<p>YD: I learned Java in 2015, and it's the language I fall back on if I need to do something.
But I don't program so much anyway.</p>
<p>JMC: Ok, thanks. Let's get back to how you got involved with Lean.</p>
<p>YD: So Kevin's talk made me realise that there's a lot more going on, and that it's not just a game.
Mathwise, I figured out a lot along the way.
Leanwise, I learned a lot from Bhavik [JMC: Mehta], from him supervising me.</p>
<p>JMC: How did you meet him?</p>
<p>Just around that time, there were summer internships in Cambridge advertised on some webpage.
I applied for an internship on a Isabelle project,
and at the same time I rushed through <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics">Kevin's workshop</a>.
In the end, I didn't get that internship, but I continued doing the tutorials.
After that, I hung around on the Xena Discord server,
where I asked a tonne of questions.
I was probably quite annoying at that point.
But Bhavik helped me a lot.</p>
<p>Back then, Bhavik was working on a formalisation of <a href="https://en.wikipedia.org/wiki/Sperner%27s_lemma">Sperner's lemma</a>.
At some point I asked him if I could provide any help, and he said "Yes, sure!".
So then we started hacking on the <a href="https://github.com/leanprover-community/mathlib/tree/sperner-again">sperner-again</a> branch.</p>
<p>JMC: So this was in April, or?</p>
<p>YD: The middle of March, actually.
And that's what I worked on all my Easter holidays, which are very long in Cambridge.
Basically till the end of April.
I wrote about 6000 lines of code, most of which is pretty crappy to be honest.</p>
<p><strong>JMC: Around that time you also started contributing to mathlib. Which parts have you worked on?</strong></p>
<p>YD: It can be divided into three areas.</p>
<p>The first is convex analysis.
As I said, I was working on Sperner's lemma, which never hit mathlib.
But we might continue it soon, so maybe it will then.
Anyway, for this work, we needed several lemmas that were missing from mathlib.
I also enjoy formalizing random bits of convex analysis,
because it is elementary and I understood how to do it right.
And in September I led the convexity refactor.
It's not completely done yet.
I plan to do the next steps during my Christmas holidays.</p>
<p>The second part is order theory.
I think it's the first place that I really understood to the core;
how the hierarchy is built; how the typeclasses interact;
and what kind of properties we expect from each thing;
and just how everything fits together.
Here I contributed the definitions of circular orders and locally finite orders
and many missing lemmas.
There always are missing lemmas.
And together with Yakov [JMC: Pechersky], I'm working on refactoring bits of this hierarchy,
such as conditionally complete orders.</p>
<p>The third area I worked on is combinatorics.
Not much on my work there is in mathlib yet.
What I did this summer is Szemerédi's regularity lemma,
and the stuff that follows from it, such as Roth's theorem.
But this is all living on a branch that Bhavik and I are working on.
And then I'm working on graph theory.
But there's the usual problem with graph theory in mathlib:
there are lots of interested people, lots of ideas, but nothing gets PR'd.
Finally, I'm taking the old Kruskal-Katona branch of Bhavik,
and turning that into PRs to mathlib.</p>
<p>And all of these are related.
With Bhavik, we are now considering formalizing a proof of Szemerédi's theorem,
which generalises Roth's theorem.
For this we will need Hales-Jewett, which David Wärn recently contributed,
Sperner's theorem, which is in Bhavik's Kruskal-Katona branch,
and a generalisation of that called Density Hales-Jewett.
We are studying the Polymath-inspired proof.</p>
<p><strong>JMC: That's a lot. Probably the refactors have been the most visible to the outside.
Can you give us some insight into the brain of someone who does a refactor?
What goes on behind the scenes?</strong></p>
<p>YD: Hmmmm. Everything starts with an annoyance.
You are on your way to somewhere, and suddenly your foot stumbles upon something,
something that is not quite right.
You inspect closer, you look onto the ground; and BAM! there is a rabbit hole.
And of course, you have to look into it.
You can't just leave it there, that's not something one should do.
You have to inspect the rabbit hole, and maybe fill it up.
I'm very prone to doing that, because I guess I'm pathologically perfectionistic.
So I go down this rabbit hole, and there's an entire cave behind it.
And I just can't leave anymore: I have to figure out how to deal with it.
And that's how it happened with the convexity refactor, with the finite intervals,
and all others.
For example, the PR on Minkowski functionals depended on 12 other PRs that I made,
which were all filling up little gaps that I stumbled upon.</p>
<p>JMC: So the rabbit hole, the annoyance, that's how you get drawn into it.
But in the end, something has to happen.
You need to write code, it has to be PR'd, in order to improve mathlib.
And this can be nontrivial.
So how do you move from observing the rabbit hole and the cave behind it,
to some effective actions that improve the situation?</p>
<p>YD: Well, you map the cave.
Maybe you go outside for a while, bring your friends in, chat around a picnic.
For example, I discussed a lot with Yakov about the convexity refactor.
In fact, he was probably the person who got me started with it.
You better have that conversation now, before you find yourself with a crappy remblai.
The cave is there. It's not going anywhere.
You know you will eventually have to fill it up,
but there is no urge in doing so.
There's usually little incentive in rushing a refactor.</p>
<p>JMC: Can you briefly sketch what the rabbit hole was in the case of the convexity refactor?</p>
<p>YD: So, what the rabbit hole was:
until August 2021, convexity in mathlib was only defined for sets in real vector spaces.
This is very restraining, for various reasons.
Sometimes you want to talk about convexity over the rational numbers.
Yakov wanted to do tropical geometry,
so then you only have an ordered semiring, not an ordered ring.
There is no additive inverse in that setting.
That's why he originally asked for the refactor.
Similarly, Yury [JMC: Kudryashov] wanted to apply convexity to measures.
But measures are a positive thing, so again you don't have additive inverses.</p>
<p>So a first generalization could be to replace the real numbers by a linearly ordered field.
But as the last two examples show, that's not sufficient. It doesn't bring much.
So the bulk of the work is to take those big files with all the lemmas,
and separate them out, stratify them,
according to how much structure is needed to prove them.
When I started, I had quickly figured out that ordered rings should be sufficient for almost all of it.
But then Yakov pointed out to me that even ordered semiring should be enough
(because he had tropical geometry in mind).
And that's how it started.
So for each lemma, you look at the typeclass assumptions,
and try to replace them by something weaker, until something breaks.
And if it breaks but you think it shouldn't, then you try to fix the proof.
Now repeat that, like 500 times.</p>
<p>I got it wrong the first time.
I didn't localise my changes, as we say.
I started by replacing all of the convex stuff,
by changing all the lemmas to assume ordered semirings, everywhere;
and then tried to fix all the problems, as they showed up.
And I ended up changing 40 files, which wasn't very efficient,
and it didn't go anywhere.</p>
<p>So then I thought about it a bit harder,
and decided that I would only change the first file, which defines convexity.
So I did that, and PR'd it.
And after some discussion, it got merged.
(The discussion brought up another rabbit hole, concerning affine spaces.)</p>
<p>And when the first file was done,
I checked which files were one step higher in the import hierarchy.
And then I generalized those files.
And in this fashion you work your way through the files, going further and further.
In the end, I found the process quite straightforward.
And along the way I learned a lot about scalar actions in mathlib;
actions, modules, associativity constraints when different objects act on each other simultaneously...
I'm very glad I did this refactor.
Most of the pain came from waiting for the poor reviewers to look at the 500-line diffs on github.</p>
<p>JMC: So first there is the rabbit hole, and then your first attempt at refactoring, which failed.
Then you tried again, in a more systematic way, which worked better.
And then you start PR'ing things.
By that time you've gone through lots of different thoughts and ideas and options,
and settled on a particular approach.
And now you have to convey your ideas to the rest of the community,
and make them understand that this is the best direction.
How did that go?</p>
<p>YD: For the convexity refactor, it went quite well.
Because in that case it was a clear win.
Everything we could do before [the refactor], we could do after.
The only payoff was that we now have to write the ring of scalars explicitly
when stating that a set is convex,
because there are potentially multiple candidate rings of scalars.</p>
<p>One thing that I took away was that people wanted me to do smaller PR's.
Localising your changes is really the way to go.
Maintainers don't want to have several thousand lines of code to digest.
And they might want to say no to a small portion of it, but they are ok with the rest.
And the only way to go about that
is either to block the PR entirely,
which means the process becomes much slower,
or you split the PR up.
And this splitting is a part where you have to think a bit,
because you have to figure along which lines you can cut up your PR.</p>
<p>In my case there was an obvious choice.
Because I wasn't functionally changing anything,
only generalizing things,
I could just do it file by file;
and that's how it happened.</p>
<p>There is also another pragmatic fact.
Mathlib grows fast, and files get touched often.
If you want to avoid your PR rotting away in a queue of "too big refactors"
you need to make it small so that it goes through quickly and unconflicted.
The time that it takes to review a PR is not proportional to its size,
but maybe to the square of its size, or something.
That's just an empirical observation.</p>
<p><strong>JMC: Yes, that sounds true to me.
So, you've talked about three areas that you've worked on with Lean.
If you had to choose, which one are you the most proud of?</strong></p>
<p>YD: Well, I guess they didn't bring the same things to me.</p>
<p>The work in order theory just satisfies my needs for tidiness.
Convex analysis got me into the right way of doing PR's.
It taught me the process,
and how to get your stuff accepted by others.
And finally, combinatorics didn't bring me either of those.
Because, firstly, none of it is in mathlib,
secondly, there are lots of design decisions that are arguable
and I don't think it's in its final form already.
But it brought me recognition from outside the formalisation community.
The latest of course being Tim Gowers with his
<a href="https://twitter.com/wtgowers/status/1459271456865591298">tweet</a>
mentioning my work with Bhavik.
I actually met Tim last week, by accident.
And he's really interested in what we are doing.
Formal theorem proving is now something that mathematicians can do and get something out of it.</p>
<p>JMC: But if you had to choose one? I guess Szemerédi, right?</p>
<p>YD: Yes, it's very fashionable. It's definitely something I'm proud of.</p>
<p><strong>JMC: Has contributing to mathlib changed the way you think about any part of mathematics?</strong></p>
<p>YD: Oh yes, definitely.
Formalising in general, maybe not contributing to mathlib in particular,
is really getting into the backscene of mathematics.
You start to notice structures that wouldn't have occurred to you otherwise.</p>
<p>For example, hierarchies. They are ubiquitous.
Personally, I had not realised how structuring it is to mathematics
that mathematical structures have some kind of order between them,
that vertically there is a natural way to go from one to the next,
and horizontally a natural way to build up the same structure over more and more complicated types.</p>
<p>This brings me to monadic structures.
It's a nice way to think about things.
Once you empirically understand how monads work (you don't even have to get the theory),
you start seeing them all over the place; Many things that I was defining had a monadic structure to them.
For example, I needed something about some gadget, which turns out to be its <code>bind</code> operation.
That gadget is built on top of other gadgets, so what I did was to prove their <code>bind</code> operation first,
and I wouldn't have thought about that before.
Knowing about monads makes you consider these statements [JMC: as useful building blocks].</p>
<p>Another thing is that people abuse language.
And it's not a thing that as a beginner you really grasp.
I was trying to learn a bit of category theory, maybe a year ago.
And I kind of got stuck at functors, for a stupid reason.
Because people use the notation $F(A)$ to mean the image of the object $A$
and also $F(f)$ to mean the image of the morphism $f$.
And it's really dumb, but as a beginner the confusion prevents you from seeing that there is something happening.
And in mathlib it's spelt out: a functor is two functions, and they behave correctly.</p>
<p>Finally, I think it brings an organic approach to proof-writing.
Because you really get that each thing has <em>one</em> definition.
And you understand how to interact with that definition.
You start to understand how the API around it works,
so the wrapper around it that allows you to do basic stuff with the definition.
And this API dawns on you how proofs about a specific object work.</p>
<p>There's actually some math that I learned while doing Lean.
Topology, with Kevin's workshop.
So I found out things: to use compactness you need an open cover,
and you get a finite subcover, and you can use that to do other things.
And it becomes automatic at some point.
You have this program, and it leads you, it leads your intuition through the proofs.</p>
<p>In some sense, that's also why TabNine and Copilot [JMC: two editor plugins] are so impressive.
They really work quite well at guessing what is coming next.
And working with formal proofs makes you have some sort of Copilot in your head.</p>
<p><strong>JMC: What are your plans for the next year?</strong></p>
<p>YD: Actually, there are several things going on. I'm really trying to get Bhavik's branch into mathlib.
And also, of course, Szemerédi's regularity lemma.
Which are both things that will take a while,
and hopefully they will be done by the end of January.
I wouldn't be surprised if it's taking longer.
There is also the <code>sperner-again</code> branch, which has lots of stuff that is ready for mathlib.
Some of that stuff is seven months old,
but the process of getting things into mathlib can be excruciatingly slow.</p>
<p><strong>JMC: Yes, certainly. Which is connected to the next few questions.
I will just ask them as a batch, and then you can pick in which order you answer them.
What change would you like to see in the community?
What would help you to work more effectively with mathlib and/or Lean?
What do you enjoy the most? What could increase the fun?</strong></p>
<p>YD: Honestly, the community is great! And Zulip is very effective.
There is some stuff that I would like to see changed,
but I realise that it's not very feasible,
because people have a life.
I would just like to see PRs getting quicker through the review process.
Because it's arguably very long.
I'm trying to review PRs myself, but sometimes it's hard.
Part of the reason is, we're not that many.</p>
<p>JMC: I agree, I would also like to see it go faster.
At the same time, mathlib has a pretty fast reviewing process already.
But I certainly recognise the feeling:
"Ooh, my PR has been sitting there for 3 days. What's going on?!"
So, do you see some actionable thing that could be changed?</p>
<p>YD: I think there is not much that we can do by ourselves.
I think what we need is more people who are capable of reviewing PRs,
which will come with a bigger community.
On the other hand, I'm not sure that improves the situation.
Because more people means more PRs!</p>
<p>JMC: Is there something that could be done to make it easier for people to review PRs?</p>
<p>YD: Initially I didn't review PRs,
because I didn't feel confident that I could add something.
But now that I've made many PRs myself,
I know what is going on, and I'm now much more active in the review process.
So it's not something for beginners.
It's a subtle question.
There's knowledge that is not easy to acquire. You have to go through the process.</p>
<p>Maybe we could have some sort of event.
Where people can, maybe not review, but at least read through PRs.
And see if they can catch anything mathematically meaningful?
That they would like to see changed.
That would be something where people can get a sense of the [other side of the] reviewing process.
Maybe once a month? First Saturday of the month? A read-a-pr day.</p>
<p>JMC: It's certainly a tricky problem to solve.
But it would be fantastic if every PR could be reviewed in a couple of days.</p>
<p>YD: Anyway, it's hard to complain about such a community.
There are so many things that work well.
The "new members" stream on Zulip;
people actually care about new members.
They are taken on board,
even if most questions are quite repetitive
and maybe pointless to an expert eye.
People still take the time to answer them.
And in general, if you ask a question on Zulip,
you will get an answer in less than 10 minutes.</p>
<p>JMC: So you mentioned TabNine and Copilot already.
Are there any other things that would make you work more effectively?</p>
<p>YD: Something like Sledgehammer, for if you just want to bash through a proof.
That would be fantastic.
Another thing is that Lean is slow.
I notice that I have an upper bound on my coding speed
because it takes a while before Lean updates the goal.
And it's really painful when you have to wait 3 seconds at each keystroke.
Had it been faster, I could have done some random thing in 10 minutes,
but I spent 1h30 instead.
And this happens for several reasons:
long proofs and long files.
If Lean could provide support for more granular recompilation of long proofs,
that would be great.
By now, many of the large files have been split into smaller pieces,
and I am working on some of the remaining ones.</p>
<p><strong>JMC: Thanks for all your answers! It's time for the final two questions.
Do you have a question for the next interviewee?</strong></p>
<p>YD: One thing I really like about mathlib is that it makes you appreciate the power of collaboration.
Were it not for building on the work of others, I could have never achieved anything in Lean.
My question is:
In which ways did you find the community helped you?</p>
<p><strong>JMC: And do you have any parting words or proverbial wisdom that you want to share with us?</strong></p>
<p>YD: Localize your changes, split a PR.</p>
<p><strong>JMC: A great suggestion. Thanks a lot for your time!</strong></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/semilinear-maps/" class="u-url">Semilinear maps</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/frederic-dupuis/">Frédéric Dupuis</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/semilinear-maps/" rel="bookmark">
            <time class="published dt-published" datetime="2021-12-11T12:00:00+01:00" itemprop="datePublished" title="2021-12-11 12:00">2021-12-11 12:00</time></a>
            </p>
		    <p><span class="text-dark">New in mathlib</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>Since linear maps appear everywhere in mathematics, it comes as no surprise that they have been part of mathlib for quite some time. However, as we were working on adding the basics of functional analysis to mathlib, a drawback quickly became apparent: conjugate-linear maps could not directly be expressed as linear maps. This meant that some constructions could not be formulated in their most natural way: for example, the map that takes an operator to its adjoint on a complex Hilbert space is a conjugate linear map, and so is the Riesz representation that maps a vector to its dual. This was also preventing us from developing the orthogonal group, the unitary group, etc, properly.</p>
<p>A few options were considered to introduce conjugate-linear maps. One possible way was to define the <a href="https://en.wikipedia.org/wiki/Complex_conjugate_vector_space">conjugate space</a> of <code>E</code> as a type copy where scalar multiplication is conjugated. Then, a conjugate-linear maps is a standard linear map to the conjugate space. This would have enabled us to reuse the API of linear maps without having too much to refactor, but an early attempt to do this was abandoned when converting between the conjugate space and the original space proved to be unwieldy. A further disadvantage is that the type copy would have also appeared in the real case for constructions involving <code>is_R_or_C</code>. Another potential solution to the problem was to define conjugate-linear maps separately from linear maps. The big drawback here is that the API for linear maps would effectively have to be duplicated for those new maps.</p>
<p>This left the more arduous option, namely to redefine <code>linear_map</code> to also include semilinear maps. A semilinear map <code>f</code> is a map from an <code>R</code>-module to an <code>S</code>-module with a ring homomorphism <code>σ</code> between <code>R</code> and <code>S</code>, such that <code>f (c • x) = (σ c) • (f x)</code>. If we plug in the identity into <code>σ</code>, we get regular linear maps, and if we plug in the complex conjugate, we get conjugate linear maps. There are also other examples (e.g. Frobenius-linear maps) where this is useful which are covered by this general formulation. This implied a major refactor: we had to replace the basic definition of <code>R</code>-linear maps <code>E →ₗ[R] F</code> by <code>σ</code>-semilinear maps <code>E →ₛₗ[σ] F</code> while keeping the original notation for plain linear maps, and deal with the various problems that this inevitably created further down the import tree. The same also had to be done for linear equivalences, continuous linear maps/equivalences, and linear isometries. This idea had first been proposed by Yury Kudryashov <a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214442983">about a year ago</a>, but it then took several months to build up the motivation to embark on this project. Last July, Heather Macbeth, Rob Lewis and I finally managed to start working on it, and the result was <a href="https://github.com/leanprover-community/mathlib/pull/9272">merged</a> into mathlib in late September.</p>
<p>The main issue that we had to overcome involved composition of semilinear maps, and <code>symm</code> for linear equivalences. Suppose we have <code>f : E₁ →ₛₗ[σ₁₂] E₂</code> and <code>g : E₂ →ₛₗ[σ₂₃] E₃</code>, we would naturally end up with <code>g.comp f : E₁ →ₛₗ[σ₂₃.comp σ₁₂] E₃</code>. However, in most cases of interest, this is very awkward: suppose, for example, that we have defined the adjoint as a conjugate-linear map: <code>adjoint : (E →ₗ[ℂ] F) →ₛₗ[conj] (F →ₗ[ℂ] E)</code>, and want to express the fact that the adjoint of the adjoint is the identity; in other words, we want a lemma like<sup id="fnref:1"><a class="footnote-ref" href="posts/semilinear-maps/#fn:1">1</a></sup>:</p>
<pre class="code literal-block">lemma adjoint_adjoint : adjoint.comp adjoint = (id : E →ₗ[ℂ] F)
</pre>
<p>However, the general composition lemma for semilinear maps wouldn't give us this: the <code>id</code> on the right-hand side would actually be of type <code>E →ₛₗ[conj.comp conj] F</code>! A similar problem arises for <code>symm</code> for a semilinear equivalence. Suppose we have a semilinear equivalence <code>e : E ≃ₛₗ[σ] F</code>, then <code>e.symm</code> will naturally be of type <code>F ≃ₛₗ[σ.symm] E</code>. Again this is undesirable in interesting cases: suppose we have defined the Riesz representation of a vector (i.e. the map that takes a vector <code>v : E</code> to its dual <code>λ x, ⟪v, x⟫</code> in a Hilbert space) as a conjugate-linear equivalence <code>to_dual : E ≃ₛₗ[conj] (dual E)</code>. Then, of course we want <code>to_dual.symm</code> to be of type <code>(dual E) ≃ₛₗ[conj] E</code>, but the general lemma regarding <code>symm</code> will yield a map of type <code>(dual E) ≃ₛₗ[conj.symm] E</code>.</p>
<p>To solve these two issues, we created two typeclasses to make Lean infer the right ring homomorphism. The first one is <code>[ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃]</code> which expresses the fact that <code>σ₂₃.comp σ₁₂ = σ₁₃</code>, and the second one is <code>[ring_hom_inv_pair σ₁₂ σ₂₁]</code> which states that <code>σ₁₂</code> and <code>σ₂₁</code> are inverses of each other. The ring homomorphism <code>σ₁₃</code> (resp. <code>σ₂₁</code>) is inferred silently by the typeclass system using <code>out_param</code>. Then, to make our two examples go through properly, we just need to add instances for <code>ring_hom_comp_triple conj conj id</code> and <code>ring_hom_inv_pair conj conj</code>. There is also a third typeclass <code>[ring_hom_surjective σ]</code>, which is a necessary assumption to generalize some basic lemmas.</p>
<p>This refactor is now mostly complete ("mostly" because there are still lots of lemmas left to generalize!), and we have also <a href="https://github.com/leanprover-community/mathlib/pull/9875">added notation</a> specifically for conjugate-linear maps: <code>E →ₗ⋆[ℂ] F</code> denotes conjugate-linear maps from <code>E</code> to <code>F</code>. Such maps are now slowly starting to appear, with the Riesz representation in <a href="https://github.com/leanprover-community/mathlib/pull/9924">PR #9924</a>, and the adjoint coming soon!</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>The examples given here have been simplified to get to the core of the issue; in reality, these maps would involve <em>continuous</em> linear maps, we would most likely have to specify the type of <code>adjoint</code> for Lean to infer the correct types, etc. <a class="footnote-backref" href="posts/semilinear-maps/#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/month-in-mathlib-nov-2021/" class="u-url">This month in mathlib (Nov 2021)</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/mathlib-community/">Mathlib community</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/month-in-mathlib-nov-2021/" rel="bookmark">
            <time class="published dt-published" datetime="2021-12-06T06:58:04+01:00" itemprop="datePublished" title="2021-12-06 06:58">2021-12-06 06:58</time></a>
            </p>
		    <p><span class="text-dark">month-in-mathlib</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>This post summarizes some of the activity that happened in mathlib in November.</p>
<ul>
<li>
<p>Geometry and algebraic topology.</p>
<ul>
<li>The series 
  <a href="https://github.com/leanprover-community/mathlib/pull/10284">PR #10284</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10297">PR #10297</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10303">PR #10303</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10328">PR #10328</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10334">PR #10334</a>,
  and <a href="https://github.com/leanprover-community/mathlib/pull/10401">PR #10401</a>
  constructs the sheafification of presheaves with respect to
  a Grothendieck topology on a category, culminating with a construction
  of colimits in the category <code>SheafedSpace</code>. It is an important building block in
  setting up algebraic geometry, as well as a requirement for the
  <a href="https://github.com/leanprover-community/lean-liquid">Liquid Tensor Experiment</a> 
  (LTE). A corollary is that the category of
  sheaves with values in a suitable concrete abelian category is itself
  an abelian category. This has been formalised for LTE, and should
  appear in mathlib in the near future.</li>
<li>Barycentric coordinates have been further studied in a series of PRs including for instance
  <a href="https://github.com/leanprover-community/mathlib/pull/10320">PR #10320</a> relating them to determinants.      </li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10381">PR #10381</a>
  proves the orthogonal group is generated by reflections.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10195">PR #10195</a>
  defines the fundamental groupoid, as functor from <code>Top</code> to
  <code>Groupoid</code>.</li>
</ul>
</li>
<li>
<p>Number theory.</p>
<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9071">PR #9071</a> defines the class number of number fields and function fields.
  This finishes the finiteness proof of the class group of a number field and function field,
  described in <a href="https://leanprover-community.github.io/blog/posts/dedekind-domains-and-class-number-in-lean/">a previous blog post</a>.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/8820">PR #8820</a> adds  Lucas primality test.</li>
</ul>
</li>
<li>
<p>Group theory.</p>
<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10059">PR #10059</a> proves that (infinite) Sylow subgroups are isomorphic.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10283">PR #10283</a> proves the full Schur-Zassenhaus theorem.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10249">PR #10249</a> defines the exponent of a group.</li>
</ul>
</li>
<li>
<p>Combinatorics.</p>
<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10029">PR #10029</a> proves
 Hindman's theorem on finite sums.</li>
<li>Set families are making their way to mathlib with
  <a href="https://github.com/leanprover-community/mathlib/pull/9926">PR #9926</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10223">PR #10223</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10238">PR #10238</a>
  respectively defining antichains, shadow of a set family, UV compression.
  Those are ingredients for
  the <a href="https://en.wikipedia.org/wiki/Lubell%E2%80%93Yamamoto%E2%80%93Meshalkin_inequality">LYM inequality</a>,
  <a href="https://en.wikipedia.org/wiki/Sperner%27s_theorem">Sperner's theorem</a>
  and the <a href="https://en.wikipedia.org/wiki/Sperner%27s_theorem">Kruskal-Katona theorem</a>.</li>
</ul>
</li>
<li>
<p>Linear algebra and functional analysis</p>
<ul>
<li>The sequence of PRs 
  <a href="https://github.com/leanprover-community/mathlib/pull/9840">PR #9840</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/9995">PR #9995</a>,
  <a href="https://github.com/leanprover-community/mathlib/pull/10317">PR #10317</a>
  establishes the connection between eigenvalues and the Rayleigh quotient,
  and proves the diagonalization theorem for self-adjoint endomorphisms on finite-dimensional inner product spaces.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10145">PR #10145</a> introduces $C^*$-algebras.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10530">PR #10530</a> proves properties of spectrum in a Banach algebra.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9097">PR #9097</a> defines the Minkowski gauge functional.</li>
</ul>
</li>
<li>
<p>Analysis</p>
<ul>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/9791">PR #9791</a>
  proves the Picard-Lindelöf/Cauchy-Lipschitz theorem about ordinary differential equations.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10057">PR #10057</a> defines Vitali families
  and <a href="https://github.com/leanprover-community/mathlib/pull/10101">PR #10101</a> 
  shows the main theorem on differentiation of measures:
  given two measures <code>ρ</code> and <code>μ</code> on a finite-dimensional real vector space,
  the ratio <code>ρ (ball x r) / μ (ball x r)</code> converges <code>μ</code>-almost everywhere
  to the Radon-Nikodym derivative of <code>ρ</code> with respect to <code>μ</code> when <code>r</code> tends to <code>0</code>.
  The theorem is in fact proved in the more general context of Vitali families, as in Federer's famous book on geometric measure theory.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10073">PR #10073</a> proves convergence of a sequence which does not oscillate infinitely.</li>
<li>
<a href="https://github.com/leanprover-community/mathlib/pull/10258">PR #10258</a> proves that, if $u_n$ is subadditive, then $u_n / n$ converges.</li>
</ul>
</li>
</ul>
</div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/dedekind-domains-and-class-number-in-lean/" class="u-url">Dedekind domains and class number in Lean</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/anne-baanen/">Anne Baanen</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/dedekind-domains-and-class-number-in-lean/" rel="bookmark">
            <time class="published dt-published" datetime="2021-11-22T09:00:00+02:00" itemprop="datePublished" title="2021-11-22 09:00">2021-11-22 09:00</time></a>
            </p>
		    <p><span class="text-dark"></span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>Pull request <a href="https://github.com/leanprover-community/mathlib/pull/9071">#9701</a> marks the completion of a string of additions to mathlib centered around formalizing Dedekind domains and class groups of global fields (those words will be explained below). Previous PRs had shown that nonzero ideals of a Dedekind domain factor uniquely into prime ideals, and had defined class groups in some generality. The main result in this PR is the finiteness of the class group of a global field (and in particular of the ring of integers of a number field).
Formalizing these subjects has been one of my long-term goals for mathlib,
and as far as we are aware, Lean is the first system in which this level of algebraic number theory is available.
These formalizations have been joint work:
most notable contributors on the Lean side were Ashvni Narayanan, Filippo Nuccio and myself,
with Sander Dahmen developing a new finiteness proof of the class group specially for this project.
Of course, we could not have done this without the assistance of the entire mathlib community.
Sander, Ashvni, Filippo and I wrote <a href="https://github.com/lean-forward/class-number">a paper</a> on the formalization project for the <a href="http://easyconferences.eu/itp2021/">ITP 2021</a> conference;
this blog post goes through the highlights of the paper.</p>
<p>Algebraic number theory is an associative term:
parsing it as (algebraic (number theory)) we get a subarea of number theory, the study of the integer numbers, that uses algebraic techniques to solve equations such as $x^2 + 2 = y^3$.
Alternatively, we can parse ((algebraic number) theory) as the area of mathematics studying <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/algebraic.html#is_algebraic">algebraic</a> numbers, those satisfying a polynomial equation $f(\alpha) = 0$ for some nonzero polynomial $f$ with rational coefficients.
Algebraic numbers are found in <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/number_field.html#number_field"><em>number fields</em></a>, which are finite extensions of the field of rational numbers,
or equivalently fields generated by adjoining an algebraic element $\alpha$ to $\mathbb{Q}$ (by virtue of the <a href="https://leanprover-community.github.io/mathlib_docs/field_theory/primitive_element.html#field.exists_primitive_element">primitive element theorem</a>).
Much like $\mathbb{Q}$ contains the integers $\mathbb{Z}$ as a subring, a number field $K$ contains a <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/number_field.html#number_field.ring_of_integers"><em>ring of integers</em></a> $O_K$,
which consists of exactly those $x \in K$ that are the solution to a monic polynomial with integer coefficients.</p>
<p>Algebraic number theory also considers <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/function_field.html#function_field"><em>function fields</em></a>,
which are fields isomorphic to finite extensions of $\mathbb{F}_q(t)$, the field of rational polynomials over some finite field $\mathbb{F}_q$ of cardinality $q$.
Number fields and function fields together are called <em>global fields</em>, and they have a number of important characteristics in common.
Like the ring of integers $O_K$ in a number field $K$, a function field $F$ has a ring of integers $O_F$,
although in the function field case the definition depends on the realisation of $F$ as a finite extension of $\mathbb{F}_q(t)$.
In this case the integers are defined as those $x \in F$ that are the solution to a monic polynomial with coefficients in $\mathbb{F}_q[t]$.
Throughout our formalization process, we made sure to treat all global fields as uniformly as possible.</p>
<p>We spent a lot of effort on creating a useful interface to deal with field extensions such as $\mathbb{Q} \subseteq K$ and subrings such as $O_K \subseteq K$,
without having to transport everything to a subtype of a "largest relevant field" such as $\mathbb{C}$.
The <a href="https://leanprover-community.github.io/mathlib_docs/algebra/algebra/basic.html#algebra"><code>algebra</code></a> and <a href="https://leanprover-community.github.io/mathlib_docs/group_theory/group_action/defs.html#is_scalar_tower"><code>is_scalar_tower</code></a> typeclasses were invaluable
in automating away all kinds of messy detail checking.
In this context I would like to name Eric Wieser as someone whose skill in (ab)using typeclasses prevented many headaches.</p>
<p>The structure of a ring of integers is not quite as nice as the structure of $\mathbb{Z}$.
For example, while every nonzero integer factorizes uniquely into a product of prime powers,
in the ring $\mathbb{Z}[\sqrt{-5}] = O_{\mathbb{Q}(\sqrt{-5})}$ the number $6$ factorizes non-uniquely
as $6 = 2 \cdot 3$ and as $6 = (1 + \sqrt{−5})(1 − \sqrt{−5})$.
We can recover some of the useful properties by considering instead the <em>ideals</em> of $O_K$.
Indeed, recovering unique factorization was Kummer's motivation for studying "ideal numbers", the predecessor to the modern notion of ideals.
Nonzero ideals of $O_K$ do indeed factorize uniquely into products of prime ideals.
This unique ideal factorization property follows from the fact that a ring of integers is a <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#is_dedekind_domain"><em>Dedekind domain</em></a>.
Thus, we formalized that <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#integral_closure.is_dedekind_domain_fraction_ring">a ring of integers is a Dedekind domain</a> and that <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#ideal.unique_factorization_monoid">Dedekind domains have unique ideal factorization</a>.</p>
<p>A question we might ask is how far away a Dedekind domain is from unique element factorization.
In a principal ideal ring, where all ideals are principal, i.e. generated by one element,
unique factorization of elements and unique factorization of ideals are essentially the same property.
Therefore the amount of non-principal ideals tells us something about the failure of unique factorization.
The <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/class_group.html#class_group"><em>class group</em></a> $\mathrm{Cl}(R)$ of a ring $R$ is defined as the quotient of all ideals modulo the principal ideals:
$I$ and $J$ are in the same class iff $(x)I = (y)J$ for some nonzero $x, y \in R$.</p>
<p>In a ring of integers of a global field, the class group is always finite, so it makes sense to talk about the <em>class number</em> of a number field $K$,
which is the finite cardinality of $\mathrm{Cl}(O_K)$;
by the arguments above, the class number is equal to one if and only if all ideals are principal, if and only if $O_K$ has unique element factorization.
The pen-and-paper proof that the class number is finite requires some results like Minkowski's theorem that were not yet available in mathlib,
and differs significantly between the number field and function field case.
Sander designed a new finiteness proof that works uniformly for all global fields, as long as there exists something we call an <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/class_number/admissible_absolute_value.html#absolute_value.is_admissible"><em>admissible absolute value</em></a>.
Very specifically, we formalized that <a href="https://leanprover-community.github.io/mathlib_docs/number_theory/class_number/finite.html#class_group.fintype_of_admissible_of_finite">the class group of $S$ is finite if it is the integral closure of a Dedekind domain with Euclidean algorithm $R$ in a finite separable extension $L$ of the fraction field $K$ of $R$, if $R$ has an admissible absolute value</a>;
and the final PR <a href="https://github.com/leanprover-community/mathlib/pull/9071">#9701</a> shows this is indeed the case whenever $S$ is the ring of integers of a global field.</p>
<p>Before that final pull request could be merged, we ran into an unexpected issue that delayed it by about a month:
the definition of a function field relies on a field of rational functions $\mathbb{F}_q(t)$,
which we denoted in Lean as <code>fraction_ring (polynomial Fq)</code>.
Both <code>fraction_ring</code> and <code>polynomial</code>, and more importantly their field resp. ring structure, are quite complicated definitions.
This is no problem when working with them normally, however when there are missing typeclass instances Lean can end up desparately unfolding all of these definitions into their basic axioms,
causing timeouts during error reporting.
We want errors to be reported quickly and indeed Mathlib has a linter that ensures missing instances fail in the expected way,
so we needed to fix this timeout issue before the PR could get merged.
In the end, <a href="https://github.com/leanprover-community/mathlib/pull/9563">I contributed</a> a new definition of rational functions <a href="https://leanprover-community.github.io/mathlib_docs/field_theory/ratfunc.html#ratfunc"><code>ratfunc</code></a>.
Since <code>ratfunc</code> is a <code>structure</code> type, it means <code>ratfunc Fq</code> will not be unfolded so drastically and the timeout is resolved.
This is an example of timeout issues I'm running into frequently, suggesting that mathlib is running into the limitations of Lean 3's simple instance search mechanism.
Hopefully Lean 4's improved algorithm solves these issues without workarounds like having to introduce new <code>structure</code> types.</p>
<p>Having formalized the class number opens up a number of areas of future research.
My next goal is to formally compute the class group of some simple rings of integers like $\mathbb{Z}[\sqrt{-5}]$ "by hand".
Once we have a good understanding of how to do so manually, I hope to automate these calculations as much as possible,
in the end creating a tactic that takes a number field and returns its class number
(perhaps interfacing with computer algebra systems to do the hard computations, and certifying the results within Lean).
The end goal for this kind of automation is a system where you can enter an equation like $x^2 + 2 = y^3$ for $x, y \in \mathbb{Z}$,
and Lean would output a formally verified set of solutions.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/contributions-to-mathlib-from-lte-about-normed-groups/" class="u-url">Contributions to mathlib from LTE about normed groups</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/riccardo-brasca/">Riccardo Brasca</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/contributions-to-mathlib-from-lte-about-normed-groups/" rel="bookmark">
            <time class="published dt-published" datetime="2021-11-02T11:04:21+02:00" itemprop="datePublished" title="2021-11-02 11:04">2021-11-02 11:04</time></a>
            </p>
		    <p><span class="text-dark">New in mathlib</span></p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>When the <a href="https://github.com/leanprover-community/lean-liquid/">Liquid Tensor Experiment</a> started,
in December 2020, mathlib already
<a href="https://github.com/leanprover-community/mathlib/tree/c5009dd7140cf6ae53bf4ddeb57992eb10053b0b/src/analysis/normed_space">had</a>
a decent theory of normed spaces. With this post I want to show how mathlib can benefit
from projects like <a href="https://github.com/leanprover-community/lean-liquid/">LTE</a>, showing what we added
to the theory of normed spaces in almost one year of work (this is only a small part of what has
been added to mathlib from <a href="https://github.com/leanprover-community/lean-liquid/">LTE</a>, for a more
complete list, see the history of <a href="https://github.com/leanprover-community/lean-liquid/commits/master/src/for_mathlib">for_mathlib</a>
folder).</p>
<p>Besides several small missing lemmas, we added the following notions.</p>
<ul>
<li>
<code>normed_group_hom</code>: we already had the operator norm, but no bundled hom between normed
  groups. We introduced <code>normed_group_hom G H</code>, that it is itself a normed group. We also
  introduced kernels and images of a normed groups hom.</li>
<li>
<code>semi_normed_group</code>: a seminorm generalizes a norm by allowing nonzero vectors of zero
  (semi)norm. This notion is needed in <a href="https://github.com/leanprover-community/lean-liquid/">LTE</a>,
  and we introduced it in mathlib (providing a reasonable API). Since <code>normed_group</code> depends on
  <code>metric_space</code> that in turn depends on <code>emetric_space</code>, we had first of all introduced
  (extended) pseudo metric spaces. We also introduced <code>semi_normed_space</code> and similar related notions.</li>
<li>
<code>normed_group_quotient</code>: the theory of quotients of (semi) normed groups was completely
  missing. We now have a good API for it.</li>
<li>
<code>normed_group_hom.completion</code>: similarly to <code>normed_group_quotient</code>, mathlib did not know
  completions of normed groups. Using the already existing theory for topological groups,
  we added an API for completions of normed groups. </li>
<li>
<code>nnnorm</code>: sometimes it is useful to consider the norm as taking values in the nonnegative
  reals. We introduced the class <code>has_nnnorm</code>, with the obvious instances, and wrote an API for it.</li>
<li>
<code>SemiNormedGroup</code>: we introduced <code>SemiNormedGroup</code>, the category of semi normed groups,
  as a preadditive category with kernels and cokernels. We promoted <code>normed_group_hom.completion</code>
  to a functor, showing its universal property. Working with cokernels, an interesting problem
  arose: if <code>f : X → Y</code> is a normed groups hom, one usually consider <em>the</em> cokernel
  <code>coker(f) = Y/Im(f)</code>, with the quotient norm and it is obvious that the projection
  <code>π : Y → coker(f)</code> satisfies <code>∥π∥ ≤ 1</code>. This is often needed in computations, but
  the category theory API doesn't promise any particular model of the cokernel,
  so one can for example scale the quotient norm by any positive factor, ending up with another
  cokernel, whose natural projection has norm bigger than <code>1</code>. If <code>f</code> itself has norm less or
  equal than <code>1</code>, one can work with <code>SemiNormedGroup₁</code>, the category of seminormed groups and
  norm nonincreasing morphisms (that we proved has cokernels), but in general we ended up
  providing <code>explicit_cokernel f</code>, an explicit choice of cokernel, which has good properties with
  respect to the norm. This was enough for <a href="https://github.com/leanprover-community/lean-liquid/">LTE</a>,
  but still not completely satisfying, since one cannot directly use the category theory API for
  <code>explicit_cokernel</code>.</li>
</ul>
</div>
            </article>
</div>
            <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-2.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></main><footer id="footer"><p>Contents © 2022         The Lean prover community - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
        

    
    
</body>
</html>
