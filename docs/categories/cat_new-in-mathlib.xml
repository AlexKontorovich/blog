<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lean community blog (Posts about New in mathlib)</title><link>https://leanprover-community.github.io/blog/</link><description></description><atom:link href="https://leanprover-community.github.io/blog/categories/cat_new-in-mathlib.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:"&gt;The Lean prover community&lt;/a&gt; </copyright><lastBuildDate>Wed, 08 Dec 2021 23:23:43 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Contributions to mathlib from LTE about normed groups</title><link>https://leanprover-community.github.io/blog/posts/contributions-to-mathlib-from-lte-about-normed-groups/</link><dc:creator>Riccardo Brasca</dc:creator><description>&lt;div&gt;&lt;p&gt;When the &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;Liquid Tensor Experiment&lt;/a&gt; started,
in December 2020, mathlib already
&lt;a href="https://github.com/leanprover-community/mathlib/tree/c5009dd7140cf6ae53bf4ddeb57992eb10053b0b/src/analysis/normed_space"&gt;had&lt;/a&gt;
a decent theory of normed spaces. With this post I want to show how mathlib can benefit
from projects like &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;, showing what we added
to the theory of normed spaces in almost one year of work (this is only a small part of what has
been added to mathlib from &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;, for a more
complete list, see the history of &lt;a href="https://github.com/leanprover-community/lean-liquid/commits/master/src/for_mathlib"&gt;for_mathlib&lt;/a&gt;
folder).&lt;/p&gt;
&lt;p&gt;Besides several small missing lemmas, we added the following notions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;normed_group_hom&lt;/code&gt;: we already had the operator norm, but no bundled hom between normed
  groups. We introduced &lt;code&gt;normed_group_hom G H&lt;/code&gt;, that it is itself a normed group. We also
  introduced kernels and images of a normed groups hom.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semi_normed_group&lt;/code&gt;: a seminorm generalizes a norm by allowing nonzero vectors of zero
  (semi)norm. This notion is needed in &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;,
  and we introduced it in mathlib (providing a reasonable API). Since &lt;code&gt;normed_group&lt;/code&gt; depends on
  &lt;code&gt;metric_space&lt;/code&gt; that in turn depends on &lt;code&gt;emetric_space&lt;/code&gt;, we had first of all introduced
  (extended) pseudo metric spaces. We also introduced &lt;code&gt;semi_normed_space&lt;/code&gt; and similar related notions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normed_group_quotient&lt;/code&gt;: the theory of quotients of (semi) normed groups was completely
  missing. We now have a good API for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normed_group_hom.completion&lt;/code&gt;: similarly to &lt;code&gt;normed_group_quotient&lt;/code&gt;, mathlib did not know
  completions of normed groups. Using the already existing theory for topological groups,
  we added an API for completions of normed groups. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnnorm&lt;/code&gt;: sometimes it is useful to consider the norm as taking values in the nonnegative
  reals. We introduced the class &lt;code&gt;has_nnnorm&lt;/code&gt;, with the obvious instances, and wrote an API for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SemiNormedGroup&lt;/code&gt;: we introduced &lt;code&gt;SemiNormedGroup&lt;/code&gt;, the category of semi normed groups,
  as a preadditive category with kernels and cokernels. We promoted &lt;code&gt;normed_group_hom.completion&lt;/code&gt;
  to a functor, showing its universal property. Working with cokernels, an interesting problem
  arose: if &lt;code&gt;f : X → Y&lt;/code&gt; is a normed groups hom, one usually consider &lt;em&gt;the&lt;/em&gt; cokernel
  &lt;code&gt;coker(f) = Y/Im(f)&lt;/code&gt;, with the quotient norm and it is obvious that the projection
  &lt;code&gt;π : Y → coker(f)&lt;/code&gt; satisfies &lt;code&gt;∥π∥ ≤ 1&lt;/code&gt;. This is often needed in computations, but
  the category theory API doesn't promise any particular model of the cokernel,
  so one can for example scale the quotient norm by any positive factor, ending up with another
  cokernel, whose natural projection has norm bigger than &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;f&lt;/code&gt; itself has norm less or
  equal than &lt;code&gt;1&lt;/code&gt;, one can work with &lt;code&gt;SemiNormedGroup₁&lt;/code&gt;, the category of seminormed groups and
  norm nonincreasing morphisms (that we proved has cokernels), but in general we ended up
  providing &lt;code&gt;explicit_cokernel f&lt;/code&gt;, an explicit choice of cokernel, which has good properties with
  respect to the norm. This was enough for &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;,
  but still not completely satisfying, since one cannot directly use the category theory API for
  &lt;code&gt;explicit_cokernel&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/contributions-to-mathlib-from-lte-about-normed-groups/</guid><pubDate>Tue, 02 Nov 2021 09:04:21 GMT</pubDate></item><item><title>The Radon-Nikodym theorem in Lean</title><link>https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/</link><dc:creator>Kexing Ying</dc:creator><description>&lt;div&gt;&lt;p&gt;I have for the past two months been working on formalising the Radon-Nikodym theorem 
in Lean, and with &lt;a href="https://github.com/leanprover-community/mathlib/pull/9065"&gt;PR #9065&lt;/a&gt; 
merged into mathlib, this journey seems to have finally come to an end. &lt;/p&gt;
&lt;p&gt;The Radon-Nikodym theorem provides a necessary and sufficient condition for 
comparing two measures, and allows us (under certain conditions) to express 
one measure in terms of another.
The Radon-Nikodym theorem is an important result in measure theory and has a
wide range of applications in different fields of mathematics. Most notably, 
it can be applied in probability theory in the definition 
of the conditional expectation and in mathematical finance through the Girsanov 
theorem&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Given two measures $\mu$ and $\nu$ on $\alpha$, we say that $\mu$ is 
&lt;em&gt;absolutely continuous&lt;/em&gt; with respect to $\nu$ (and write $\mu \ll \nu$) if for all 
subsets $S$ of $\alpha$, $\nu(S) = 0$ implies $\mu(S) = 0$. Absolute continuity 
is an important notion for measures and we would like to establish a condition 
for when it is true. &lt;/p&gt;
&lt;p&gt;Given a measure $\mu$ on $\alpha$ and a measurable function 
$f : \alpha \to \overline{\mathbb{R}}_{\ge 0}$, the set function 
$$S \mapsto \int_S f \text{ d} \mu$$
is also a measure on $\alpha$ and we denote this measure by $f\mu$. It is 
easy, and intuitive to see that $f\mu \ll \mu$, however, it is not clear 
whether the reverse is true. The Radon-Nikodym theorem proves the reverse 
implication for certain measures. In particular, the classical Radon-Nikodym 
theorem states that two $\sigma$-finite measures $\mu, \nu$ satisfy $\mu \ll \nu$ 
if and only if there exists a measurable function $f$ such that $\mu = f\nu$. 
This function is known as the Radon-Nikodym derivative 
(denoted by $\frac{\text{d}\mu}{\text{d}\nu}$) and is essentially unique whenever 
it exists.&lt;/p&gt;
&lt;p&gt;In Lean, this is shown by &lt;code&gt;absolutely_continuous_iff_with_density_radon_nikodym_deriv_eq&lt;/code&gt;
and can be found in &lt;code&gt;measure_theory/decomposition/radon_nikodym&lt;/code&gt;.
While Radon-Nikodym is the main motivation, the proof of the theorem 
itself is rather simple once we have the prerequisites, and thus, the project 
spanned over multiple files, most of which can be found in &lt;code&gt;measure_theory/decomposition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Of all the prerequisites, the most important are the 
Jordan decomposition theorem and the Lebesgue decomposition theorem.
The Jordan decomposition theorem uniquely classifies signed measures and allows 
us to express every signed measure as a difference between two (mutually singular) 
positive measures. While the theorem itself follows from the signed Hahn decomposition, 
defining the structure of Jordan decompositions in Lean was tricky. While 
initially, the decomposition was defined as a proposition, thanks to the suggestions 
from the maintainers, it was decided to define the decomposition as a structure. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;structure&lt;/span&gt; &lt;span class="n"&gt;jordan_decomposition&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt;&lt;span class="bp"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;measurable_space&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos_part_finite&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_finite_measure&lt;/span&gt; &lt;span class="n"&gt;pos_part&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;neg_part_finite&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_finite_measure&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutually_singular&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="bp"&gt;⊥ₘ&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This was important, as later on, it was discovered that we were able to 
relax some conditions on the uniqueness property of the Lebesgue decomposition 
by introducing scalar multiplication on Jordan decompositions&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. Furthermore, 
as we would often like to transport between signed measures and Jordan 
decompositions, it is easier to work with types rather than propositions since 
this required a construction of an equivalence between the two types. &lt;/p&gt;
&lt;p&gt;A similar situation was reached with the Lebesgue decomposition. The Lebesgue 
decomposition states that given two $\sigma$-finite measures $\mu$ and $\nu$, 
there exists an essentially unique measurable function $f : \alpha \to \overline{\mathbb{R}}_{\ge 0}$ 
and a unique finite measure $\xi$ such that $\xi$ is mutually singular with respect 
to $\nu$ (denoted $\xi \perp \nu$) and $\mu = \xi + f\nu$.
As with the Jordan decomposition theorem, it was not clear how to represent this 
statement. In particular, it is important for us to be able to extract the aforementioned 
$f$ from the decomposition as this is the Radon-Nikodym derivative. After some
experiments, I decided to represent this condition using a class.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="n"&gt;measure.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Prop&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lebesgue_decomposition&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="bp"&gt;∃&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;×&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="bp"&gt;≥&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="bp"&gt;∞&lt;/span&gt;&lt;span class="o"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;measurable&lt;/span&gt; &lt;span class="n"&gt;p.2&lt;/span&gt; &lt;span class="bp"&gt;∧&lt;/span&gt; &lt;span class="n"&gt;p.1&lt;/span&gt; &lt;span class="bp"&gt;⊥ₘ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="bp"&gt;∧&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p.1&lt;/span&gt; &lt;span class="bp"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ν.with_density&lt;/span&gt; &lt;span class="n"&gt;p.2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Since in order to prove the Lebesgue decomposition for $\sigma$-finite measures, 
we will first need to show it for finite measures, this definition allows us 
to reuse the same statement for both cases, avoiding duplicate code. Furthermore, 
as we would like to extract the measure and measurable function from the decomposition, 
we may define functions that choose the decomposition if it exists, and are
zero otherwise.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;measure.singular_part&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classical.some&lt;/span&gt; &lt;span class="n"&gt;h.lebesgue_decomposition&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;measure.radon_nikodym_deriv&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="bp"&gt;≥&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="bp"&gt;∞&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classical.some&lt;/span&gt; &lt;span class="n"&gt;h.lebesgue_decomposition&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;With the Lebesgue decomposition for $\sigma$-finite measures formalized, the 
Radon-Nikodym theorem follows easily by considering that the singular part of the 
Lebesgue decomposition is zero in the case that $\mu \ll \nu$.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;theorem&lt;/span&gt; &lt;span class="n"&gt;absolutely_continuous_iff_with_density_radon_nikodym_deriv_eq&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="bp"&gt;≪&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="bp"&gt;↔&lt;/span&gt; &lt;span class="n"&gt;ν.with_density&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Furthermore, the generalisation of the 
Radon-Nikodym theorem to signed measures follows, simply by utilising 
the Jordan decomposition and realising the Radon-Nikodym derivative of 
the signed measure is the difference of the Radon-Nikodym derivatives of 
the parts of the Jordan decomposition. However, using this definition of the 
Radon-Nikodym derivative for the signed measures poses a problem, in which 
proving any properties about them requires an absolutely continuous condition.
Thus, it was decided to generalise the Lebesgue decomposition theorem for 
signed measures from which we obtain the general Radon-Nikodym theorem.&lt;/p&gt;
&lt;p&gt;Similar to the Lebesgue decomposition for the positive measures, the Lebesgue 
decomposition between a signed measure and a positive measure states that, 
given a signed measure $s$ and a $\sigma$-finite measure $\mu$, there exists 
an essentially unique measurable function $f : \alpha \to \mathbb{R}$ and a 
unique signed measure $t$, such that $t \perp \mu$ and $s = t + f\mu$.
While this version of the Lebesgue decomposition was also represented as a class, 
the statement itself was modified to be an equivalent, yet easier to work with 
statement. Namely, a signed measure $s$ has Lebesgue decomposition with respect to 
a measure $\mu$ if both parts of the Jordan decomposition of $s$ have Lebesgue 
decomposition to $\mu$.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="n"&gt;signed_measure.have_lebesgue_decomposition&lt;/span&gt; 
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Prop&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;neg_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;By the same rationale, the singular part and the Radon-Nikodym derivative of the 
decomposition are defined similarly.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;signed_measure.singular_part&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.singular_part&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_signed_measure&lt;/span&gt; &lt;span class="bp"&gt;-&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.singular_part&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_signed_measure&lt;/span&gt;

&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;signed_measure.radon_nikodym_deriv&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_real&lt;/span&gt; &lt;span class="bp"&gt;-&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_real&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Using these definitions, the Lebesgue decomposition theorem was proved easily 
and thus, also the Radon-Nikodym theorem for signed measures. Most importantly, 
however, as these definition do not require an absolutely continuous condition, 
it was possible to prove that the Radon-Nikodym derivative 
$\frac{\text{d}\mu}{\text{d}\nu}$ is essentially unique without requiring 
$\mu \ll \nu$.  &lt;/p&gt;
&lt;p&gt;As the Radon-Nikodym theorem is central to many concepts in probability theory, 
a brand new territory in mathlib is now available for us to explore,&lt;br&gt;
and with &lt;a href="https://github.com/leanprover-community/mathlib/pull/9065"&gt;PR #9065&lt;/a&gt; 
merged into mathlib, a new journey seems about to begin. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Radon%E2%80%93Nikodym_theorem#Applications"&gt;wikipedia.org/wiki/Radon-Nikodym_theorem#Applications&lt;/a&gt; &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Given a signed measure &lt;code&gt;s&lt;/code&gt;, a measure &lt;code&gt;μ&lt;/code&gt; and a real number &lt;code&gt;r&lt;/code&gt;, one may show 
&lt;code&gt;(r • s).singular_part μ = r • s.singular_part μ&lt;/code&gt; without 
requiring &lt;code&gt;have_lebesgue_decomposition s μ&lt;/code&gt; by proving that the scalar product 
with a real number and the equivalence between signed measures and Jordan 
decompositions commute. &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/</guid><pubDate>Wed, 22 Sep 2021 10:51:14 GMT</pubDate></item><item><title>Continuous partitions of unity</title><link>https://leanprover-community.github.io/blog/posts/continuous-partitions-of-unity/</link><dc:creator>Patrick Massot</dc:creator><description>&lt;div&gt;&lt;p&gt;In &lt;a href="https://github.com/leanprover-community/mathlib/pull/8281"&gt;PR #8281&lt;/a&gt;, Yury
Kudryashov completed his work on continuous and smooth partitions of unity.&lt;/p&gt;
&lt;p&gt;A continuous partition of unity on a topological space $X$ is a collection of continuous functions
$f_i : X → ℝ$ such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the supports of $f_i$ form a locally finite family of sets, i.e., for every point $x$ in $X$, there
  exists a neighborhood $U$ of $x$ such that all but finitely many functions $f_i$ are zero on $U$;&lt;/li&gt;
&lt;li&gt;the functions $f_i$ are nonnegative;&lt;/li&gt;
&lt;li&gt;the sum $\sum_i f_i(x)$ is equal to one for all $x$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While the above definition is completely standard, it is often useful to have a collection of
functions that act as a partition of unity only on some part $s$ of $X$. In that more general case,
we keep the above two conditions everywhere but ask that the sum in the last item equals one on $s$
and is less than or equal to one everywhere. This is encoded in the following Lean structure, from
&lt;code&gt;topology.partition_of_unity&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;structure&lt;/span&gt; &lt;span class="n"&gt;partition_of_unity&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt;&lt;span class="bp"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topological_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;univ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;locally_finite'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;locally_finite&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;support&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nonneg'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="bp"&gt;≤&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum_eq_one'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;∈&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;∑ᶠ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum_le_one'&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;∑ᶠ&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_fun&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="bp"&gt;≤&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The main result from that file is then the following existence theorem.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="sd"&gt;/-- If `X` is a paracompact normal topological space and `U` is an open covering of a closed set&lt;/span&gt;
&lt;span class="sd"&gt;`s`, then there exists a `partition_of_unity ι X s` that is subordinate to `U`. -/&lt;/span&gt;
&lt;span class="kd"&gt;lemma&lt;/span&gt; &lt;span class="n"&gt;exists_is_subordinate&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;normal_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;paracompact_space&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hs&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_closed&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ho&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;∀&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;is_open&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hU&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="bp"&gt;⊆&lt;/span&gt; &lt;span class="bp"&gt;⋃&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="bp"&gt;∃&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;partition_of_unity&lt;/span&gt; &lt;span class="n"&gt;ι&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f.is_subordinate&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/continuous-partitions-of-unity/</guid><pubDate>Sat, 07 Aug 2021 19:49:56 GMT</pubDate></item></channel></rss>