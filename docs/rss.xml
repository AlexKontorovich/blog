<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lean community blog</title><link>https://leanprover-community.github.io/blog/</link><description>This is the blog of the Lean prover community.</description><atom:link href="https://leanprover-community.github.io/blog/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:"&gt;The Lean prover community&lt;/a&gt; </copyright><lastBuildDate>Sat, 11 Dec 2021 12:00:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>This month in mathlib (Nov 2021)</title><link>https://leanprover-community.github.io/blog/posts/month-in-mathlib-nov-2021/</link><dc:creator>Mathlib community</dc:creator><description>&lt;div&gt;&lt;p&gt;This post summarizes some of the activity that happened in mathlib in November.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Geometry and algebraic topology.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The series 
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10284"&gt;PR #10284&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10297"&gt;PR #10297&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10303"&gt;PR #10303&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10328"&gt;PR #10328&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10334"&gt;PR #10334&lt;/a&gt;,
  and &lt;a href="https://github.com/leanprover-community/mathlib/pull/10401"&gt;PR #10401&lt;/a&gt;
  constructs the sheafification of presheaves with respect to
  a Grothendieck topology on a category, culminating with a construction
  of colimits in the category &lt;code&gt;SheafedSpace&lt;/code&gt;. It is an important building block in
  setting up algebraic geometry, as well as a requirement for the
  &lt;a href="https://github.com/leanprover-community/lean-liquid"&gt;Liquid Tensor Experiment&lt;/a&gt; 
  (LTE). A corollary is that the category of
  sheaves with values in a suitable concrete abelian category is itself
  an abelian category. This has been formalised for LTE, and should
  appear in mathlib in the near future.&lt;/li&gt;
&lt;li&gt;Barycentric coordinates have been further studied in a series of PRs including for instance
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10320"&gt;PR #10320&lt;/a&gt; relating them to determinants.      &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10381"&gt;PR #10381&lt;/a&gt;
  proves the orthogonal group is generated by reflections.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10195"&gt;PR #10195&lt;/a&gt;
  defines the fundamental groupoid, as functor from &lt;code&gt;Top&lt;/code&gt; to
  &lt;code&gt;Groupoid&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Number theory.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9071"&gt;PR #9071&lt;/a&gt; defines the class number of number fields and function fields.
  This finishes the finiteness proof of the class group of a number field and function field,
  described in &lt;a href="https://leanprover-community.github.io/blog/posts/dedekind-domains-and-class-number-in-lean/"&gt;a previous blog post&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8820"&gt;PR #8820&lt;/a&gt; adds  Lucas primality test.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Group theory.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10059"&gt;PR #10059&lt;/a&gt; proves that (infinite) Sylow subgroups are isomorphic.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10283"&gt;PR #10283&lt;/a&gt; proves the full Schur-Zassenhaus theorem.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10249"&gt;PR #10249&lt;/a&gt; defines the exponent of a group.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Combinatorics.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10029"&gt;PR #10029&lt;/a&gt; proves
 Hindman's theorem on finite sums.&lt;/li&gt;
&lt;li&gt;Set families are making their way to mathlib with
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9926"&gt;PR #9926&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10223"&gt;PR #10223&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10238"&gt;PR #10238&lt;/a&gt;
  respectively defining antichains, shadow of a set family, UV compression.
  Those are ingredients for
  the &lt;a href="https://en.wikipedia.org/wiki/Lubell%E2%80%93Yamamoto%E2%80%93Meshalkin_inequality"&gt;LYM inequality&lt;/a&gt;,
  &lt;a href="https://en.wikipedia.org/wiki/Sperner%27s_theorem"&gt;Sperner's theorem&lt;/a&gt;
  and the &lt;a href="https://en.wikipedia.org/wiki/Sperner%27s_theorem"&gt;Kruskal-Katona theorem&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linear algebra and functional analysis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sequence of PRs 
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9840"&gt;PR #9840&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9995"&gt;PR #9995&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/10317"&gt;PR #10317&lt;/a&gt;
  establishes the connection between eigenvalues and the Rayleigh quotient,
  and proves the diagonalization theorem for self-adjoint endomorphisms on finite-dimensional inner product spaces.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10145"&gt;PR #10145&lt;/a&gt; introduces $C^*$-algebras.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10530"&gt;PR #10530&lt;/a&gt; proves properties of spectrum in a Banach algebra.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9097"&gt;PR #9097&lt;/a&gt; defines the Minkowski gauge functional.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Analysis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9791"&gt;PR #9791&lt;/a&gt;
  proves the Picard-Lindelöf/Cauchy-Lipschitz theorem about ordinary differential equations.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10057"&gt;PR #10057&lt;/a&gt; defines Vitali families
  and &lt;a href="https://github.com/leanprover-community/mathlib/pull/10101"&gt;PR #10101&lt;/a&gt; 
  shows the main theorem on differentiation of measures:
  given two measures &lt;code&gt;ρ&lt;/code&gt; and &lt;code&gt;μ&lt;/code&gt; on a finite-dimensional real vector space,
  the ratio &lt;code&gt;ρ (ball x r) / μ (ball x r)&lt;/code&gt; converges &lt;code&gt;μ&lt;/code&gt;-almost everywhere
  to the Radon-Nikodym derivative of &lt;code&gt;ρ&lt;/code&gt; with respect to &lt;code&gt;μ&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; tends to &lt;code&gt;0&lt;/code&gt;.
  The theorem is in fact proved in the more general context of Vitali families, as in Federer's famous book on geometric measure theory.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10073"&gt;PR #10073&lt;/a&gt; proves convergence of a sequence which does not oscillate infinitely.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/10258"&gt;PR #10258&lt;/a&gt; proves that, if $u_n$ is subadditive, then $u_n / n$ converges.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/month-in-mathlib-nov-2021/</guid><pubDate>Mon, 06 Dec 2021 05:58:04 GMT</pubDate></item><item><title>Dedekind domains and class number in Lean</title><link>https://leanprover-community.github.io/blog/posts/dedekind-domains-and-class-number-in-lean/</link><dc:creator>Anne Baanen</dc:creator><description>&lt;div&gt;&lt;p&gt;Pull request &lt;a href="https://github.com/leanprover-community/mathlib/pull/9071"&gt;#9701&lt;/a&gt; marks the completion of a string of additions to mathlib centered around formalizing Dedekind domains and class groups of global fields (those words will be explained below). Previous PRs had shown that nonzero ideals of a Dedekind domain factor uniquely into prime ideals, and had defined class groups in some generality. The main result in this PR is the finiteness of the class group of a global field (and in particular of the ring of integers of a number field).
Formalizing these subjects has been one of my long-term goals for mathlib,
and as far as we are aware, Lean is the first system in which this level of algebraic number theory is available.
These formalizations have been joint work:
most notable contributors on the Lean side were Ashvni Narayanan, Filippo Nuccio and myself,
with Sander Dahmen developing a new finiteness proof of the class group specially for this project.
Of course, we could not have done this without the assistance of the entire mathlib community.
Sander, Ashvni, Filippo and I wrote &lt;a href="https://github.com/lean-forward/class-number"&gt;a paper&lt;/a&gt; on the formalization project for the &lt;a href="http://easyconferences.eu/itp2021/"&gt;ITP 2021&lt;/a&gt; conference;
this blog post goes through the highlights of the paper.&lt;/p&gt;
&lt;p&gt;Algebraic number theory is an associative term:
parsing it as (algebraic (number theory)) we get a subarea of number theory, the study of the integer numbers, that uses algebraic techniques to solve equations such as $x^2 + 2 = y^3$.
Alternatively, we can parse ((algebraic number) theory) as the area of mathematics studying &lt;a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/algebraic.html#is_algebraic"&gt;algebraic&lt;/a&gt; numbers, those satisfying a polynomial equation $f(\alpha) = 0$ for some nonzero polynomial $f$ with rational coefficients.
Algebraic numbers are found in &lt;a href="https://leanprover-community.github.io/mathlib_docs/number_theory/number_field.html#number_field"&gt;&lt;em&gt;number fields&lt;/em&gt;&lt;/a&gt;, which are finite extensions of the field of rational numbers,
or equivalently fields generated by adjoining an algebraic element $\alpha$ to $\mathbb{Q}$ (by virtue of the &lt;a href="https://leanprover-community.github.io/mathlib_docs/field_theory/primitive_element.html#field.exists_primitive_element"&gt;primitive element theorem&lt;/a&gt;).
Much like $\mathbb{Q}$ contains the integers $\mathbb{Z}$ as a subring, a number field $K$ contains a &lt;a href="https://leanprover-community.github.io/mathlib_docs/number_theory/number_field.html#number_field.ring_of_integers"&gt;&lt;em&gt;ring of integers&lt;/em&gt;&lt;/a&gt; $O_K$,
which consists of exactly those $x \in K$ that are the solution to a monic polynomial with integer coefficients.&lt;/p&gt;
&lt;p&gt;Algebraic number theory also considers &lt;a href="https://leanprover-community.github.io/mathlib_docs/number_theory/function_field.html#function_field"&gt;&lt;em&gt;function fields&lt;/em&gt;&lt;/a&gt;,
which are fields isomorphic to finite extensions of $\mathbb{F}_q(t)$, the field of rational polynomials over some finite field $\mathbb{F}_q$ of cardinality $q$.
Number fields and function fields together are called &lt;em&gt;global fields&lt;/em&gt;, and they have a number of important characteristics in common.
Like the ring of integers $O_K$ in a number field $K$, a function field $F$ has a ring of integers $O_F$,
although in the function field case the definition depends on the realisation of $F$ as a finite extension of $\mathbb{F}_q(t)$.
In this case the integers are defined as those $x \in F$ that are the solution to a monic polynomial with coefficients in $\mathbb{F}_q[t]$.
Throughout our formalization process, we made sure to treat all global fields as uniformly as possible.&lt;/p&gt;
&lt;p&gt;We spent a lot of effort on creating a useful interface to deal with field extensions such as $\mathbb{Q} \subseteq K$ and subrings such as $O_K \subseteq K$,
without having to transport everything to a subtype of a "largest relevant field" such as $\mathbb{C}$.
The &lt;a href="https://leanprover-community.github.io/mathlib_docs/algebra/algebra/basic.html#algebra"&gt;&lt;code&gt;algebra&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://leanprover-community.github.io/mathlib_docs/group_theory/group_action/defs.html#is_scalar_tower"&gt;&lt;code&gt;is_scalar_tower&lt;/code&gt;&lt;/a&gt; typeclasses were invaluable
in automating away all kinds of messy detail checking.
In this context I would like to name Eric Wieser as someone whose skill in (ab)using typeclasses prevented many headaches.&lt;/p&gt;
&lt;p&gt;The structure of a ring of integers is not quite as nice as the structure of $\mathbb{Z}$.
For example, while every nonzero integer factorizes uniquely into a product of prime powers,
in the ring $\mathbb{Z}[\sqrt{-5}] = O_{\mathbb{Q}(\sqrt{-5})}$ the number $6$ factorizes non-uniquely
as $6 = 2 \cdot 3$ and as $6 = (1 + \sqrt{−5})(1 − \sqrt{−5})$.
We can recover some of the useful properties by considering instead the &lt;em&gt;ideals&lt;/em&gt; of $O_K$.
Indeed, recovering unique factorization was Kummer's motivation for studying "ideal numbers", the predecessor to the modern notion of ideals.
Nonzero ideals of $O_K$ do indeed factorize uniquely into products of prime ideals.
This unique ideal factorization property follows from the fact that a ring of integers is a &lt;a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#is_dedekind_domain"&gt;&lt;em&gt;Dedekind domain&lt;/em&gt;&lt;/a&gt;.
Thus, we formalized that &lt;a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#integral_closure.is_dedekind_domain_fraction_ring"&gt;a ring of integers is a Dedekind domain&lt;/a&gt; and that &lt;a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/dedekind_domain.html#ideal.unique_factorization_monoid"&gt;Dedekind domains have unique ideal factorization&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A question we might ask is how far away a Dedekind domain is from unique element factorization.
In a principal ideal ring, where all ideals are principal, i.e. generated by one element,
unique factorization of elements and unique factorization of ideals are essentially the same property.
Therefore the amount of non-principal ideals tells us something about the failure of unique factorization.
The &lt;a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/class_group.html#class_group"&gt;&lt;em&gt;class group&lt;/em&gt;&lt;/a&gt; $\mathrm{Cl}(R)$ of a ring $R$ is defined as the quotient of all ideals modulo the principal ideals:
$I$ and $J$ are in the same class iff $(x)I = (y)J$ for some nonzero $x, y \in R$.&lt;/p&gt;
&lt;p&gt;In a ring of integers of a global field, the class group is always finite, so it makes sense to talk about the &lt;em&gt;class number&lt;/em&gt; of a number field $K$,
which is the finite cardinality of $\mathrm{Cl}(O_K)$;
by the arguments above, the class number is equal to one if and only if all ideals are principal, if and only if $O_K$ has unique element factorization.
The pen-and-paper proof that the class number is finite requires some results like Minkowski's theorem that were not yet available in mathlib,
and differs significantly between the number field and function field case.
Sander designed a new finiteness proof that works uniformly for all global fields, as long as there exists something we call an &lt;a href="https://leanprover-community.github.io/mathlib_docs/number_theory/class_number/admissible_absolute_value.html#absolute_value.is_admissible"&gt;&lt;em&gt;admissible absolute value&lt;/em&gt;&lt;/a&gt;.
Very specifically, we formalized that &lt;a href="https://leanprover-community.github.io/mathlib_docs/number_theory/class_number/finite.html#class_group.fintype_of_admissible_of_finite"&gt;the class group of $S$ is finite if it is the integral closure of a Dedekind domain with Euclidean algorithm $R$ in a finite separable extension $L$ of the fraction field $K$ of $R$, if $R$ has an admissible absolute value&lt;/a&gt;;
and the final PR &lt;a href="https://github.com/leanprover-community/mathlib/pull/9071"&gt;#9701&lt;/a&gt; shows this is indeed the case whenever $S$ is the ring of integers of a global field.&lt;/p&gt;
&lt;p&gt;Before that final pull request could be merged, we ran into an unexpected issue that delayed it by about a month:
the definition of a function field relies on a field of rational functions $\mathbb{F}_q(t)$,
which we denoted in Lean as &lt;code&gt;fraction_ring (polynomial Fq)&lt;/code&gt;.
Both &lt;code&gt;fraction_ring&lt;/code&gt; and &lt;code&gt;polynomial&lt;/code&gt;, and more importantly their field resp. ring structure, are quite complicated definitions.
This is no problem when working with them normally, however when there are missing typeclass instances Lean can end up desparately unfolding all of these definitions into their basic axioms,
causing timeouts during error reporting.
We want errors to be reported quickly and indeed Mathlib has a linter that ensures missing instances fail in the expected way,
so we needed to fix this timeout issue before the PR could get merged.
In the end, &lt;a href="https://github.com/leanprover-community/mathlib/pull/9563"&gt;I contributed&lt;/a&gt; a new definition of rational functions &lt;a href="https://leanprover-community.github.io/mathlib_docs/field_theory/ratfunc.html#ratfunc"&gt;&lt;code&gt;ratfunc&lt;/code&gt;&lt;/a&gt;.
Since &lt;code&gt;ratfunc&lt;/code&gt; is a &lt;code&gt;structure&lt;/code&gt; type, it means &lt;code&gt;ratfunc Fq&lt;/code&gt; will not be unfolded so drastically and the timeout is resolved.
This is an example of timeout issues I'm running into frequently, suggesting that mathlib is running into the limitations of Lean 3's simple instance search mechanism.
Hopefully Lean 4's improved algorithm solves these issues without workarounds like having to introduce new &lt;code&gt;structure&lt;/code&gt; types.&lt;/p&gt;
&lt;p&gt;Having formalized the class number opens up a number of areas of future research.
My next goal is to formally compute the class group of some simple rings of integers like $\mathbb{Z}[\sqrt{-5}]$ "by hand".
Once we have a good understanding of how to do so manually, I hope to automate these calculations as much as possible,
in the end creating a tactic that takes a number field and returns its class number
(perhaps interfacing with computer algebra systems to do the hard computations, and certifying the results within Lean).
The end goal for this kind of automation is a system where you can enter an equation like $x^2 + 2 = y^3$ for $x, y \in \mathbb{Z}$,
and Lean would output a formally verified set of solutions.&lt;/p&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/dedekind-domains-and-class-number-in-lean/</guid><pubDate>Mon, 22 Nov 2021 07:00:00 GMT</pubDate></item><item><title>Semilinear maps</title><link>https://leanprover-community.github.io/blog/posts/semilinear-maps/</link><dc:creator>Frédéric Dupuis</dc:creator><description>&lt;div&gt;&lt;p&gt;Since linear maps appear everywhere in mathematics, it comes as no surprise that they have been part of mathlib for quite some time. However, as we were working on adding the basics of functional analysis to mathlib, a drawback quickly became apparent: conjugate-linear maps could not directly be expressed as linear maps. This meant that some constructions could not be formulated in their most natural way: for example, the map that takes an operator to its adjoint on a complex Hilbert space is a conjugate linear map, and so is the Riesz representation that maps a vector to its dual. This was also preventing us from developing the orthogonal group, the unitary group, etc, properly.&lt;/p&gt;
&lt;p&gt;A few options were considered to introduce conjugate-linear maps. One possible way was to define the &lt;a href="https://en.wikipedia.org/wiki/Complex_conjugate_vector_space"&gt;conjugate space&lt;/a&gt; of &lt;code&gt;E&lt;/code&gt; as a type copy where scalar multiplication is conjugated. Then, a conjugate-linear maps is a standard linear map to the conjugate space. This would have enabled us to reuse the API of linear maps without having too much to refactor, but an early attempt to do this was abandoned when converting between the conjugate space and the original space proved to be unwieldy. A further disadvantage is that the type copy would have also appeared in the real case for constructions involving &lt;code&gt;is_R_or_C&lt;/code&gt;. Another potential solution to the problem was to define conjugate-linear maps separately from linear maps. The big drawback here is that the API for linear maps would effectively have to be duplicated for those new maps.&lt;/p&gt;
&lt;p&gt;This left the more arduous option, namely to redefine &lt;code&gt;linear_map&lt;/code&gt; to also include semilinear maps. A semilinear map &lt;code&gt;f&lt;/code&gt; is a map from an &lt;code&gt;R&lt;/code&gt;-module to an &lt;code&gt;S&lt;/code&gt;-module with a ring homomorphism &lt;code&gt;σ&lt;/code&gt; between &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;, such that &lt;code&gt;f (c • x) = (σ c) • (f x)&lt;/code&gt;. If we plug in the identity into &lt;code&gt;σ&lt;/code&gt;, we get regular linear maps, and if we plug in the complex conjugate, we get conjugate linear maps. There are also other examples (e.g. Frobenius-linear maps) where this is useful which are covered by this general formulation. This implied a major refactor: we had to replace the basic definition of &lt;code&gt;R&lt;/code&gt;-linear maps &lt;code&gt;E →ₗ[R] F&lt;/code&gt; by &lt;code&gt;σ&lt;/code&gt;-semilinear maps &lt;code&gt;E →ₛₗ[σ] F&lt;/code&gt; while keeping the original notation for plain linear maps, and deal with the various problems that this inevitably created further down the import tree. The same also had to be done for linear equivalences, continuous linear maps/equivalences, and linear isometries. This idea had first been proposed by Yury Kudryashov &lt;a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214442983"&gt;about a year ago&lt;/a&gt;, but it then took several months to build up the motivation to embark on this project. Last August, Heather Macbeth, Rob Lewis and I finally managed to start working on it, and the result was &lt;a href="https://github.com/leanprover-community/mathlib/pull/9272"&gt;merged&lt;/a&gt; into mathlib in late September.&lt;/p&gt;
&lt;p&gt;The main issue that we had to overcome involved composition of semilinear maps, and &lt;code&gt;symm&lt;/code&gt; for linear equivalences. Suppose we have &lt;code&gt;f : E₁ →ₛₗ[σ₁₂] E₂&lt;/code&gt; and &lt;code&gt;g : E₂ →ₛₗ[σ₂₃] E₃&lt;/code&gt;, we would naturally end up with &lt;code&gt;g.comp f : E₁ →ₛₗ[σ₂₃.comp σ₁₂] E₃&lt;/code&gt;. However, in most cases of interest, this is very awkward: suppose, for example, that we have defined the adjoint as a conjugate-linear map: &lt;code&gt;adjoint : (E →ₗ[ℂ] F) →ₛₗ[conj] (F →ₗ[ℂ] E)&lt;/code&gt;, and want to express the fact that the adjoint of the adjoint is the identity; in other words, we want a lemma like&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/semilinear-maps/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;lemma adjoint_adjoint : adjoint.comp adjoint = (id : E →ₗ[ℂ] F)
&lt;/pre&gt;
&lt;p&gt;However, the general composition lemma for semilinear maps wouldn't give us this: the &lt;code&gt;id&lt;/code&gt; on the right-hand side would actually be of type &lt;code&gt;E →ₛₗ[conj.comp conj] F&lt;/code&gt;! A similar problem arises for &lt;code&gt;symm&lt;/code&gt; for a semilinear equivalence. Suppose we have a semilinear equivalence &lt;code&gt;e : E ≃ₛₗ[σ] F&lt;/code&gt;, then &lt;code&gt;e.symm&lt;/code&gt; will naturally be of type &lt;code&gt;F ≃ₛₗ[σ.symm] E&lt;/code&gt;. Again this is undesirable in interesting cases: suppose we have defined the Riesz representation of a vector (i.e. the map that takes a vector &lt;code&gt;v : E&lt;/code&gt; to its dual &lt;code&gt;λ x, ⟪v, x⟫&lt;/code&gt; in a Hilbert space) as a conjugate-linear equivalence &lt;code&gt;to_dual : E ≃ₛₗ[conj] (dual E)&lt;/code&gt;. Then, of course we want &lt;code&gt;to_dual.symm&lt;/code&gt; to be of type &lt;code&gt;(dual E) ≃ₛₗ[conj] E&lt;/code&gt;, but the general lemma regarding &lt;code&gt;symm&lt;/code&gt; will yield a map of type &lt;code&gt;(dual E) ≃ₛₗ[conj.symm] E&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To solve these two issues, we created two typeclasses to make Lean infer the right ring homomorphism. The first one is &lt;code&gt;[ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃]&lt;/code&gt; which expresses the fact that &lt;code&gt;σ₂₃.comp σ₁₂ = σ₁₃&lt;/code&gt;, and the second one is &lt;code&gt;[ring_hom_inv_pair σ₁₂ σ₂₁]&lt;/code&gt; which states that &lt;code&gt;σ₁₂&lt;/code&gt; and &lt;code&gt;σ₂₁&lt;/code&gt; are inverses of each other. The ring homomorphism &lt;code&gt;σ₁₃&lt;/code&gt; (resp. &lt;code&gt;σ₂₁&lt;/code&gt;) is inferred silently by the typeclass system using &lt;code&gt;out_param&lt;/code&gt;. Then, to make our two examples go through properly, we just need to add instances for &lt;code&gt;ring_hom_comp_triple conj conj id&lt;/code&gt; and &lt;code&gt;ring_hom_inv_pair conj conj&lt;/code&gt;. There is also a third typeclass &lt;code&gt;[ring_hom_surjective σ]&lt;/code&gt;, which is a necessary assumption to generalize some basic lemmas.&lt;/p&gt;
&lt;p&gt;This refactor is now mostly complete ("mostly" because there are still lots of lemmas left to generalize!), and we have also &lt;a href="https://github.com/leanprover-community/mathlib/pull/9875"&gt;added notation&lt;/a&gt; specifically for conjugate-linear maps: &lt;code&gt;E →ₗ⋆[ℂ] F&lt;/code&gt; denotes conjugate-linear maps from &lt;code&gt;E&lt;/code&gt; to &lt;code&gt;F&lt;/code&gt;. Such maps are now slowly starting to appear, with the Riesz representation in &lt;a href="https://github.com/leanprover-community/mathlib/pull/9924"&gt;PR #9924&lt;/a&gt;, and the adjoint coming soon!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;The examples given here have been simplified to get to the core of the issue; in reality, these maps would involve &lt;em&gt;continuous&lt;/em&gt; linear maps, we would most likely have to specify the type of &lt;code&gt;adjoint&lt;/code&gt; for Lean to infer the correct types, etc. &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/semilinear-maps/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/semilinear-maps/</guid><pubDate>Sat, 13 Nov 2021 15:23:15 GMT</pubDate></item><item><title>Contributions to mathlib from LTE about normed groups</title><link>https://leanprover-community.github.io/blog/posts/contributions-to-mathlib-from-lte-about-normed-groups/</link><dc:creator>Riccardo Brasca</dc:creator><description>&lt;div&gt;&lt;p&gt;When the &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;Liquid Tensor Experiment&lt;/a&gt; started,
in December 2020, mathlib already
&lt;a href="https://github.com/leanprover-community/mathlib/tree/c5009dd7140cf6ae53bf4ddeb57992eb10053b0b/src/analysis/normed_space"&gt;had&lt;/a&gt;
a decent theory of normed spaces. With this post I want to show how mathlib can benefit
from projects like &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;, showing what we added
to the theory of normed spaces in almost one year of work (this is only a small part of what has
been added to mathlib from &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;, for a more
complete list, see the history of &lt;a href="https://github.com/leanprover-community/lean-liquid/commits/master/src/for_mathlib"&gt;for_mathlib&lt;/a&gt;
folder).&lt;/p&gt;
&lt;p&gt;Besides several small missing lemmas, we added the following notions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;normed_group_hom&lt;/code&gt;: we already had the operator norm, but no bundled hom between normed
  groups. We introduced &lt;code&gt;normed_group_hom G H&lt;/code&gt;, that it is itself a normed group. We also
  introduced kernels and images of a normed groups hom.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semi_normed_group&lt;/code&gt;: a seminorm generalizes a norm by allowing nonzero vectors of zero
  (semi)norm. This notion is needed in &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;,
  and we introduced it in mathlib (providing a reasonable API). Since &lt;code&gt;normed_group&lt;/code&gt; depends on
  &lt;code&gt;metric_space&lt;/code&gt; that in turn depends on &lt;code&gt;emetric_space&lt;/code&gt;, we had first of all introduced
  (extended) pseudo metric spaces. We also introduced &lt;code&gt;semi_normed_space&lt;/code&gt; and similar related notions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normed_group_quotient&lt;/code&gt;: the theory of quotients of (semi) normed groups was completely
  missing. We now have a good API for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normed_group_hom.completion&lt;/code&gt;: similarly to &lt;code&gt;normed_group_quotient&lt;/code&gt;, mathlib did not know
  completions of normed groups. Using the already existing theory for topological groups,
  we added an API for completions of normed groups. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnnorm&lt;/code&gt;: sometimes it is useful to consider the norm as taking values in the nonnegative
  reals. We introduced the class &lt;code&gt;has_nnnorm&lt;/code&gt;, with the obvious instances, and wrote an API for it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SemiNormedGroup&lt;/code&gt;: we introduced &lt;code&gt;SemiNormedGroup&lt;/code&gt;, the category of semi normed groups,
  as a preadditive category with kernels and cokernels. We promoted &lt;code&gt;normed_group_hom.completion&lt;/code&gt;
  to a functor, showing its universal property. Working with cokernels, an interesting problem
  arose: if &lt;code&gt;f : X → Y&lt;/code&gt; is a normed groups hom, one usually consider &lt;em&gt;the&lt;/em&gt; cokernel
  &lt;code&gt;coker(f) = Y/Im(f)&lt;/code&gt;, with the quotient norm and it is obvious that the projection
  &lt;code&gt;π : Y → coker(f)&lt;/code&gt; satisfies &lt;code&gt;∥π∥ ≤ 1&lt;/code&gt;. This is often needed in computations, but
  the category theory API doesn't promise any particular model of the cokernel,
  so one can for example scale the quotient norm by any positive factor, ending up with another
  cokernel, whose natural projection has norm bigger than &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;f&lt;/code&gt; itself has norm less or
  equal than &lt;code&gt;1&lt;/code&gt;, one can work with &lt;code&gt;SemiNormedGroup₁&lt;/code&gt;, the category of seminormed groups and
  norm nonincreasing morphisms (that we proved has cokernels), but in general we ended up
  providing &lt;code&gt;explicit_cokernel f&lt;/code&gt;, an explicit choice of cokernel, which has good properties with
  respect to the norm. This was enough for &lt;a href="https://github.com/leanprover-community/lean-liquid/"&gt;LTE&lt;/a&gt;,
  but still not completely satisfying, since one cannot directly use the category theory API for
  &lt;code&gt;explicit_cokernel&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/contributions-to-mathlib-from-lte-about-normed-groups/</guid><pubDate>Tue, 02 Nov 2021 09:04:21 GMT</pubDate></item><item><title>This month in mathlib (Oct 2021)</title><link>https://leanprover-community.github.io/blog/posts/month-in-mathlib-oct-2021/</link><dc:creator>Mathlib community</dc:creator><description>&lt;div&gt;&lt;p&gt;This post summarizes some of the activity that happened in mathlib in October.&lt;/p&gt;
&lt;h3&gt;Highlighted PRs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In algebraic geometry, there has been a surge in activity.
  After the definition of schemes entered mathlib, the development stalled for a while,
  because the Liquid Tensor Experiment took up a lot of energy and attention.
  But new contributors showed up, and are pushing the library forward.
  Two highlights this month include:&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9416"&gt;PR #9416&lt;/a&gt; Global sections of the spectrum of a ring are isomorphic to that ring.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9861"&gt;PR #9861&lt;/a&gt; Closed points in the prime spectrum correspond to maximal ideals.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In commutative algebra:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;algebraic indepence and transcendence are introduced in 
&lt;a href="https://github.com/leanprover-community/mathlib/pull/9229"&gt;PR #9229&lt;/a&gt; and 
&lt;a href="https://github.com/leanprover-community/mathlib/pull/9377"&gt;PR #9377&lt;/a&gt; proved
the existence of transcendence bases. 
See the &lt;a href="https://stacks.math.columbia.edu/tag/030D"&gt;stacks project&lt;/a&gt; for an informal account.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9817"&gt;PR #9817&lt;/a&gt; and &lt;a href="https://github.com/leanprover-community/mathlib/pull/9834"&gt;PR #9834&lt;/a&gt;
fills a glaring hole in the field theory library: finite fields of the same cardinality are isomorphic.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In group theory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8976"&gt;PR #8976&lt;/a&gt; proves the Jordan Hölder theorem. It also proves a version for submodules.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9662"&gt;PR #9662&lt;/a&gt;
proves Frattini's Argument: If $N$ is a normal subgroup of $G$, and $P$ is
a Sylow $p$-subgroup of $N$, then $\text{N}_G(P)*N=G$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In number theory, &lt;a href="https://github.com/leanprover-community/mathlib/pull/9646"&gt;PR #9646&lt;/a&gt; and 
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9702"&gt;PR #9702&lt;/a&gt; prove that Liouville numbers form a dense $G_δ$ set which has measure zero.&lt;/li&gt;
&lt;li&gt;In combinatorics, &lt;a href="https://github.com/leanprover-community/mathlib/pull/7825"&gt;PR #7825&lt;/a&gt; proves a
  generalized version of Hall's marriage theorem using a compactness argument.
  Using the language of category theory, there is an inverse system of solutions to the marriage problem when restricted to finite subsets of the domain,
  and &lt;a href="https://leanprover-community.github.io/mathlib_docs/topology/category/Top/limits.html#nonempty_sections_of_fintype_inverse_system"&gt;the limit of this kind of inverse system is nonempty&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;In measure theory, the series of PRs &lt;a href="https://github.com/leanprover-community/mathlib/pull/9462"&gt;PR #9462&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9461"&gt;PR #9461&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9576"&gt;PR #9576&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9679"&gt;PR #9679&lt;/a&gt; and
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9680"&gt;PR #9680&lt;/a&gt;
  prove the Vitali and Besicovitch covering theorems (with
  the optimal constant for the Besicovitch covering theorem, following 
  &lt;a href="https://www.jstor.org/stable/2161215"&gt;Füredi and Loeb, On the best constant for the Besicovitch covering theorem&lt;/a&gt;).
  These theorems ensure that, from a covering of a (not necessarily measurable)
  set $s$ by nice enough sets (e.g. balls), one can extract a disjoint subfamily
  covering almost all $s$. They are instrumental in forthcoming results on
  differentiation of measures.&lt;/li&gt;
&lt;li&gt;In probability:&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9323"&gt;PR #9323&lt;/a&gt; defines probability density functions, &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9378"&gt;PR #9378&lt;/a&gt; proves that conditional expectation on real functions equal Radon-Nikodym derivative&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9469"&gt;PR #9469&lt;/a&gt; brought us notations that really demonstrate we're now doing probability in mathlib!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In algebraic topology, &lt;a href="https://github.com/leanprover-community/mathlib/pull/9252"&gt;PR #9252&lt;/a&gt; and
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9141"&gt;PR #9141&lt;/a&gt; set up some basic homotopy theory.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In topological algebra, some foundational parts of the perfectoid project were moved to mathlib after a long time of inactivity:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9521"&gt;PR #9521&lt;/a&gt; defines the adic topology associated to an ideal&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9589"&gt;PR #9589&lt;/a&gt; defines the topology associated to a valuation on a ring and proves its fundamental properties. In particular a valuation on a field &lt;code&gt;𝕂&lt;/code&gt; is extended to the completion of &lt;code&gt;𝕂&lt;/code&gt; with respect to the valuation topology.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In differential calculus, &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9496"&gt;PR #9496&lt;/a&gt; and &lt;a href="https://github.com/leanprover-community/mathlib/pull/9811"&gt;PR #9811&lt;/a&gt; prove the divergence theorem on a box, for a Henstock-style integral and the Bochner integral respectively. This is a foundational result that will be used in complex analysis and differential topology.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9440"&gt;PR #9440&lt;/a&gt; defines superpolynomial decay of a function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In functional analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9540"&gt;PR #9540&lt;/a&gt; proves the open mapping theorem for maps between affine spaces&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9924"&gt;PR #9924&lt;/a&gt;
   states the Riesz representation theorem uniformly over $ℝ$ and $ℂ$. In
   2020, Frédéric Dupuis proved this theorem over both $ℝ$ and $ℂ$ (see &lt;a href="https://github.com/leanprover-community/mathlib/pull/4379"&gt;PR
   #4379&lt;/a&gt;),
   but, since mathlib lacked conjugate-linear maps at that time,
   the $ℂ$-version was stated in a rather awkward way.
   Conjugate-linear maps were added to mathlib &lt;a href="https://leanprover-community.github.io/blog/posts/month-in-mathlib-sep-2021/"&gt;last month&lt;/a&gt; and now the $ℝ$ and $ℂ$ versions of the theorem can be stated uniformly.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The core version of Lean was bumped twice in the past month.
  Most of the &lt;a href="https://github.com/leanprover-community/lean/blob/master/doc/changes.md#3350c-28-october-2021"&gt;changes&lt;/a&gt;
  are in preparation for porting mathlib to Lean 4.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9824"&gt;PR #9824&lt;/a&gt; update to Lean-3.34.0&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9988"&gt;PR #9988&lt;/a&gt; update to Lean-3.35.0c&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/month-in-mathlib-oct-2021/</guid><pubDate>Mon, 01 Nov 2021 05:38:50 GMT</pubDate></item><item><title>Hoskinson Center announced</title><link>https://leanprover-community.github.io/blog/posts/hoskinson-center-announced/</link><dc:creator>Jeremy Avigad</dc:creator><description>&lt;div&gt;&lt;p&gt;On September 22, 2021, Carnegie Mellon University announced that a $20 million gift
from blockchain entrepreneur Charles C. Hoskinson will be used to establish the Hoskinson
Center for Formal Mathematics, housed in the Department of Philosophy.
You can read the &lt;a href="https://www.cmu.edu/news/stories/archives/2021/september/hoskinson-center-for-formal-mathematics.html"&gt;university press release&lt;/a&gt; and
watch Hoskinson's &lt;a href="https://www.youtube.com/watch?v=3snIzhjqsk0&amp;amp;ab_channel=CharlesHoskinson"&gt;YouTube announcement&lt;/a&gt;. You can also watch
&lt;a href="https://www.youtube.com/watch?v=gCLJOrJFLZQ&amp;amp;ab_channel=IOHK"&gt;Hoskinson's presentation&lt;/a&gt; and
&lt;a href="https://www.youtube.com/watch?v=tbz6cdnFyPc&amp;amp;ab_channel=IOHK"&gt;my presentation&lt;/a&gt; at an
inauguration ceremony that was held at Carnegie Mellon the day before.
The slides I used for the presentation are &lt;a href="https://www.andrew.cmu.edu/user/avigad/Talks/hoskinson_inaugural.pdf"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The center's mission is to support the work being done by the Lean community,
to promote the use of Lean and its libraries,
and to seek out ways of using the technology to make mathematics accessible and enjoyable to
as wide an audience as possible.&lt;/p&gt;
&lt;p&gt;The initial endowment will be used to support postdoctoral researchers and graduate students,
as well as occasional meetings and visitors.
In the near future, the center will focus on supporting the port of mathlib to Lean 4,
developing automation and the user interface, and, perhaps most importantly,
preparing textbooks and educational materials based on Lean.&lt;/p&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/hoskinson-center-announced/</guid><pubDate>Sat, 02 Oct 2021 21:39:15 GMT</pubDate></item><item><title>This month in mathlib (Sep 2021)</title><link>https://leanprover-community.github.io/blog/posts/month-in-mathlib-sep-2021/</link><dc:creator>Mathlib community</dc:creator><description>&lt;div&gt;&lt;p&gt;This post summarizes some of the activity that happened in mathlib in September.&lt;/p&gt;
&lt;h3&gt;Highlighted PRs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Number fields.
  The &lt;a href="https://github.com/lean-forward/class-number"&gt;Dedekind saga&lt;/a&gt; continues with
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8847"&gt;PR #8847&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8701"&gt;PR #8701&lt;/a&gt; (define number fields, rings of integers),
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8949"&gt;PR #8949&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8964"&gt;PR #8964&lt;/a&gt;, and
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9063"&gt;PR #9063&lt;/a&gt;,
  culminating in
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9059"&gt;PR #9059&lt;/a&gt;
  which shows that, in the presence of an admissible absolute value, the class group of an integral closure is finite.&lt;/li&gt;
&lt;li&gt;Probability theory.
  Foundations of probability theory are (finally!) coming to mathlib.
  With
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8939"&gt;PR #8939&lt;/a&gt; and
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8920"&gt;PR #8920&lt;/a&gt; (conditional expectation of an indicator)
  the way was open for
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9114"&gt;PR #9114&lt;/a&gt;
  which defines the conditional expectation of a function.&lt;/li&gt;
&lt;li&gt;Algebraic closures.
  Over two years ago,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/1297"&gt;PR #1297&lt;/a&gt;
  was opened, showing that algebraic closures are unique (up to non-unique isomorphism).
  Due to various issues, the material was not yet in shape for inclusion in mathlib.
  Over summer, the material got a facelift, leading to
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9110"&gt;PR #9110&lt;/a&gt;,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9231"&gt;PR #9231&lt;/a&gt;, and
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9376"&gt;PR #9376&lt;/a&gt;.
  There probably are no other commits that had to wait so long before being merged into mathlib.&lt;/li&gt;
&lt;li&gt;Riesz theorem on compact unit ball and finite dimension.
  Mathlib now knows the main difference between the topology of real normed
  spaces in finite and infinite dimensions: the closed unit ball in such a
  space is compact if and only if the space is finite dimensional. The
  implication from finite dimension to compactness was proved in
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/1687"&gt;PR #1687&lt;/a&gt;
  and &lt;a href="https://github.com/leanprover-community/mathlib/pull/9147"&gt;PR #9147&lt;/a&gt;
  proves the converse.&lt;/li&gt;
&lt;li&gt;Measure theory.
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9325"&gt;PR #9325&lt;/a&gt;
  shows that any additive Haar measure on a finite-dimensional real vector space is rescaled by a linear map through its determinant,
  and computes the measure of balls and spheres.
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9065"&gt;PR #9065&lt;/a&gt; adds Radon-Nikodym and Lebesgue decomposition for signed measures,
  see &lt;a href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/"&gt;this blogpost&lt;/a&gt; for more details.&lt;/li&gt;
&lt;li&gt;Henselian local rings. 
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8986"&gt;PR #8986&lt;/a&gt; 
  sets up the theory of Henselian rings. A ring $R$ is &lt;em&gt;Henselian&lt;/em&gt; at an ideal 
  $I$ if the following conditions hold:  &lt;ul&gt;
&lt;li&gt;$I$ is contained in the Jacobson radical of $R$&lt;/li&gt;
&lt;li&gt;for every polynomial $f$ over $R$, with a &lt;em&gt;simple&lt;/em&gt; root $a₀$ over the
  quotient ring $R/I$, there exists a lift $a ∈ R$ of $a₀$ that is a root 
  of $f$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Semilinear maps.
  Several people undertook a massive refactor to generalize linear maps to semilinear maps.
  This opens the door for the use of semilinear maps in functional analysis,
  but also Frobenius semilinear maps in characteristic $p &amp;gt; 0$.
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/8857"&gt;PR #8857&lt;/a&gt; introduces notation for &lt;code&gt;linear_map.comp&lt;/code&gt; and &lt;code&gt;linear_equiv.trans&lt;/code&gt;
  which makes it easy to work with identity-semilinear maps (aka, linear maps) without getting distracted by the redundant semilinearity conditions.
  With this notation in place,
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9272"&gt;PR #9272&lt;/a&gt; performs the actual redefinition of &lt;code&gt;linear_map&lt;/code&gt; and &lt;code&gt;linear_equiv&lt;/code&gt; to be semilinear.&lt;/li&gt;
&lt;li&gt;Convexity refactor.
  Another ongoing refactor aims to massively generalize and restructure material on convex sets/functions.
  One of the gems in a long stream of PRs shows that it is now trivial to deduce concave results from their convex counterparts:
  &lt;a href="https://github.com/leanprover-community/mathlib/pull/9356"&gt;PR #9356&lt;/a&gt; generalizes lemmas about convexity/concavity of functions, and proves concave Jensen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Other mathematical contributions&lt;/h3&gt;
&lt;p&gt;The following PRs are ordered by the date that they were merged into mathlib.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8894"&gt;PR #8894&lt;/a&gt;: add topological localization&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8962"&gt;PR #8962&lt;/a&gt;: Prove (co)reflectivity for Kan extensions&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8801"&gt;PR #8801&lt;/a&gt;: class formula, Burnside's lemma&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8947"&gt;PR #8947&lt;/a&gt;: Define homotopy between functions&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8946"&gt;PR #8946&lt;/a&gt;: rigid (autonomous) monoidal categories&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/8579"&gt;PR #8579&lt;/a&gt;: one-point compactification of a topological space (the Stone-Cech compactification had been around for ages, and now its little brother joined the gang)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9165"&gt;PR #9165&lt;/a&gt;: upgrade to Lean 3.33.0c&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/leanprover-community/mathlib/pull/9288"&gt;PR #9288&lt;/a&gt;: Sylow's theorems for infinite groups&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/month-in-mathlib-sep-2021/</guid><pubDate>Fri, 01 Oct 2021 07:00:05 GMT</pubDate></item><item><title>The Radon-Nikodym theorem in Lean</title><link>https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/</link><dc:creator>Kexing Ying</dc:creator><description>&lt;div&gt;&lt;p&gt;I have for the past two months been working on formalising the Radon-Nikodym theorem 
in Lean, and with &lt;a href="https://github.com/leanprover-community/mathlib/pull/9065"&gt;PR #9065&lt;/a&gt; 
merged into mathlib, this journey seems to have finally come to an end. &lt;/p&gt;
&lt;p&gt;The Radon-Nikodym theorem provides a necessary and sufficient condition for 
comparing two measures, and allows us (under certain conditions) to express 
one measure in terms of another.
The Radon-Nikodym theorem is an important result in measure theory and has a
wide range of applications in different fields of mathematics. Most notably, 
it can be applied in probability theory in the definition 
of the conditional expectation and in mathematical finance through the Girsanov 
theorem&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Given two measures $\mu$ and $\nu$ on $\alpha$, we say that $\mu$ is 
&lt;em&gt;absolutely continuous&lt;/em&gt; with respect to $\nu$ (and write $\mu \ll \nu$) if for all 
subsets $S$ of $\alpha$, $\nu(S) = 0$ implies $\mu(S) = 0$. Absolute continuity 
is an important notion for measures and we would like to establish a condition 
for when it is true. &lt;/p&gt;
&lt;p&gt;Given a measure $\mu$ on $\alpha$ and a measurable function 
$f : \alpha \to \overline{\mathbb{R}}_{\ge 0}$, the set function 
$$S \mapsto \int_S f \text{ d} \mu$$
is also a measure on $\alpha$ and we denote this measure by $f\mu$. It is 
easy, and intuitive to see that $f\mu \ll \mu$, however, it is not clear 
whether the reverse is true. The Radon-Nikodym theorem proves the reverse 
implication for certain measures. In particular, the classical Radon-Nikodym 
theorem states that two $\sigma$-finite measures $\mu, \nu$ satisfy $\mu \ll \nu$ 
if and only if there exists a measurable function $f$ such that $\mu = f\nu$. 
This function is known as the Radon-Nikodym derivative 
(denoted by $\frac{\text{d}\mu}{\text{d}\nu}$) and is essentially unique whenever 
it exists.&lt;/p&gt;
&lt;p&gt;In Lean, this is shown by &lt;code&gt;absolutely_continuous_iff_with_density_radon_nikodym_deriv_eq&lt;/code&gt;
and can be found in &lt;code&gt;measure_theory/decomposition/radon_nikodym&lt;/code&gt;.
While Radon-Nikodym is the main motivation, the proof of the theorem 
itself is rather simple once we have the prerequisites, and thus, the project 
spanned over multiple files, most of which can be found in &lt;code&gt;measure_theory/decomposition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Of all the prerequisites, the most important are the 
Jordan decomposition theorem and the Lebesgue decomposition theorem.
The Jordan decomposition theorem uniquely classifies signed measures and allows 
us to express every signed measure as a difference between two (mutually singular) 
positive measures. While the theorem itself follows from the signed Hahn decomposition, 
defining the structure of Jordan decompositions in Lean was tricky. While 
initially, the decomposition was defined as a proposition, thanks to the suggestions 
from the maintainers, it was decided to define the decomposition as a structure. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;structure&lt;/span&gt; &lt;span class="n"&gt;jordan_decomposition&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt;&lt;span class="bp"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;measurable_space&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos_part_finite&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_finite_measure&lt;/span&gt; &lt;span class="n"&gt;pos_part&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;neg_part_finite&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;is_finite_measure&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutually_singular&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="bp"&gt;⊥ₘ&lt;/span&gt; &lt;span class="n"&gt;neg_part&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This was important, as later on, it was discovered that we were able to 
relax some conditions on the uniqueness property of the Lebesgue decomposition 
by introducing scalar multiplication on Jordan decompositions&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. Furthermore, 
as we would often like to transport between signed measures and Jordan 
decompositions, it is easier to work with types rather than propositions since 
this required a construction of an equivalence between the two types. &lt;/p&gt;
&lt;p&gt;A similar situation was reached with the Lebesgue decomposition. The Lebesgue 
decomposition states that given two $\sigma$-finite measures $\mu$ and $\nu$, 
there exists an essentially unique measurable function $f : \alpha \to \overline{\mathbb{R}}_{\ge 0}$ 
and a unique finite measure $\xi$ such that $\xi$ is mutually singular with respect 
to $\nu$ (denoted $\xi \perp \nu$) and $\mu = \xi + f\nu$.
As with the Jordan decomposition theorem, it was not clear how to represent this 
statement. In particular, it is important for us to be able to extract the aforementioned 
$f$ from the decomposition as this is the Radon-Nikodym derivative. After some
experiments, I decided to represent this condition using a class.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="n"&gt;measure.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Prop&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lebesgue_decomposition&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="bp"&gt;∃&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;×&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="bp"&gt;≥&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="bp"&gt;∞&lt;/span&gt;&lt;span class="o"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;measurable&lt;/span&gt; &lt;span class="n"&gt;p.2&lt;/span&gt; &lt;span class="bp"&gt;∧&lt;/span&gt; &lt;span class="n"&gt;p.1&lt;/span&gt; &lt;span class="bp"&gt;⊥ₘ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="bp"&gt;∧&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p.1&lt;/span&gt; &lt;span class="bp"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ν.with_density&lt;/span&gt; &lt;span class="n"&gt;p.2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Since in order to prove the Lebesgue decomposition for $\sigma$-finite measures, 
we will first need to show it for finite measures, this definition allows us 
to reuse the same statement for both cases, avoiding duplicate code. Furthermore, 
as we would like to extract the measure and measurable function from the decomposition, 
we may define functions that choose the decomposition if it exists, and are
zero otherwise.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;measure.singular_part&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classical.some&lt;/span&gt; &lt;span class="n"&gt;h.lebesgue_decomposition&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;measure.radon_nikodym_deriv&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt;&lt;span class="bp"&gt;≥&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="bp"&gt;∞&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classical.some&lt;/span&gt; &lt;span class="n"&gt;h.lebesgue_decomposition&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;With the Lebesgue decomposition for $\sigma$-finite measures formalized, the 
Radon-Nikodym theorem follows easily by considering that the singular part of the 
Lebesgue decomposition is zero in the case that $\mu \ll \nu$.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;theorem&lt;/span&gt; &lt;span class="n"&gt;absolutely_continuous_iff_with_density_radon_nikodym_deriv_eq&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="bp"&gt;≪&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt; &lt;span class="bp"&gt;↔&lt;/span&gt; &lt;span class="n"&gt;ν.with_density&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;ν&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="bp"&gt;=&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Furthermore, the generalisation of the 
Radon-Nikodym theorem to signed measures follows, simply by utilising 
the Jordan decomposition and realising the Radon-Nikodym derivative of 
the signed measure is the difference of the Radon-Nikodym derivatives of 
the parts of the Jordan decomposition. However, using this definition of the 
Radon-Nikodym derivative for the signed measures poses a problem, in which 
proving any properties about them requires an absolutely continuous condition.
Thus, it was decided to generalise the Lebesgue decomposition theorem for 
signed measures from which we obtain the general Radon-Nikodym theorem.&lt;/p&gt;
&lt;p&gt;Similar to the Lebesgue decomposition for the positive measures, the Lebesgue 
decomposition between a signed measure and a positive measure states that, 
given a signed measure $s$ and a $\sigma$-finite measure $\mu$, there exists 
an essentially unique measurable function $f : \alpha \to \mathbb{R}$ and a 
unique signed measure $t$, such that $t \perp \mu$ and $s = t + f\mu$.
While this version of the Lebesgue decomposition was also represented as a class, 
the statement itself was modified to be an equivalent, yet easier to work with 
statement. Namely, a signed measure $s$ has Lebesgue decomposition with respect to 
a measure $\mu$ if both parts of the Jordan decomposition of $s$ have Lebesgue 
decomposition to $\mu$.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="n"&gt;signed_measure.have_lebesgue_decomposition&lt;/span&gt; 
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Prop&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;neg_part&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.have_lebesgue_decomposition&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;By the same rationale, the singular part and the Radon-Nikodym derivative of the 
decomposition are defined similarly.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;signed_measure.singular_part&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.singular_part&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_signed_measure&lt;/span&gt; &lt;span class="bp"&gt;-&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.singular_part&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_signed_measure&lt;/span&gt;

&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;signed_measure.radon_nikodym_deriv&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signed_measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;α&lt;/span&gt; &lt;span class="bp"&gt;→&lt;/span&gt; &lt;span class="n"&gt;ℝ&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="bp"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.pos_part.radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_real&lt;/span&gt; &lt;span class="bp"&gt;-&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s.to_jordan_decomposition.neg_part.radon_nikodym_deriv&lt;/span&gt; &lt;span class="n"&gt;μ&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_real&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Using these definitions, the Lebesgue decomposition theorem was proved easily 
and thus, also the Radon-Nikodym theorem for signed measures. Most importantly, 
however, as these definition do not require an absolutely continuous condition, 
it was possible to prove that the Radon-Nikodym derivative 
$\frac{\text{d}\mu}{\text{d}\nu}$ is essentially unique without requiring 
$\mu \ll \nu$.  &lt;/p&gt;
&lt;p&gt;As the Radon-Nikodym theorem is central to many concepts in probability theory, 
a brand new territory in mathlib is now available for us to explore,&lt;br&gt;
and with &lt;a href="https://github.com/leanprover-community/mathlib/pull/9065"&gt;PR #9065&lt;/a&gt; 
merged into mathlib, a new journey seems about to begin. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Radon%E2%80%93Nikodym_theorem#Applications"&gt;wikipedia.org/wiki/Radon-Nikodym_theorem#Applications&lt;/a&gt; &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Given a signed measure &lt;code&gt;s&lt;/code&gt;, a measure &lt;code&gt;μ&lt;/code&gt; and a real number &lt;code&gt;r&lt;/code&gt;, one may show 
&lt;code&gt;(r • s).singular_part μ = r • s.singular_part μ&lt;/code&gt; without 
requiring &lt;code&gt;have_lebesgue_decomposition s μ&lt;/code&gt; by proving that the scalar product 
with a real number and the equivalence between signed measures and Jordan 
decompositions commute. &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/the-radon-nikodym-theorem-in-lean/</guid><pubDate>Wed, 22 Sep 2021 10:51:14 GMT</pubDate></item><item><title>Alex Best’s type class generalization paper</title><link>https://leanprover-community.github.io/blog/posts/alex-bests-type-class-generalization-paper/</link><dc:creator>Patrick Massot</dc:creator><description>&lt;div&gt;&lt;p&gt;Alex J. Best wrote a 
&lt;a href="https://easychair.org/publications/preprint/KLfT"&gt;paper about type class generalization&lt;/a&gt; for the 
&lt;a href="https://cicm-conference.org/2021/"&gt;CICM 2021&lt;/a&gt; conference on intelligent computer
mathematics. &lt;/p&gt;
&lt;p&gt;When producing large formally verified mathematical developments that
make use of typeclasses as in mathlib, it is easy to introduce overly strong
assumptions for theorems and definitions. This paper considers the problem of
recognizing from the elaborated proof terms when typeclass assumptions
are stronger than necessary. It uses a Lean metaprogram that finds and
informs the user about possible generalizations.&lt;/p&gt;
&lt;p&gt;A nice example from the paper deals with the following theorem stating that
given a ring homomorphism between two fields and a natural number $p$, one of the
fields has characteristic p if and only if the other has characteristic $p$
(including $p = 0$):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;lemma&lt;/span&gt; &lt;span class="n"&gt;ring_hom.char_p_iff_char_p&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt;&lt;span class="bp"&gt;∗&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="bp"&gt;→+∗&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ℕ&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;char_p&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="bp"&gt;↔&lt;/span&gt; &lt;span class="n"&gt;char_p&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="kd"&gt;begin&lt;/span&gt;
  &lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="bp"&gt;;&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;introI&lt;/span&gt; &lt;span class="n"&gt;_c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constructor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;intro&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;rw&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;←&lt;/span&gt; &lt;span class="bp"&gt;@&lt;/span&gt;&lt;span class="n"&gt;char_p.cast_eq_zero_iff&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;_c&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;←&lt;/span&gt; &lt;span class="n"&gt;f.injective.eq_iff&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f.map_nat_cast&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;f.map_zero&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;We see that the proof script splits the iff statement into each direction, but
both directions are proved by the same tactic block. It is non-trivial to
determine just by reading the proof given what the weakest assumptions possible
are, and it is not immediately clear from the statement either.
The meta-program determined these are that $K$ should be a division ring, and $L$
should be a nontrivial semiring.&lt;/p&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/alex-bests-type-class-generalization-paper/</guid><pubDate>Sun, 19 Sep 2021 19:04:01 GMT</pubDate></item><item><title>Yury Kudryashov’s rotation number paper</title><link>https://leanprover-community.github.io/blog/posts/yury-kudryashovs-rotation-number-paper/</link><dc:creator>Patrick Massot</dc:creator><description>&lt;div&gt;&lt;p&gt;Yury Kudryashov wrote a 
&lt;a href="https://easychair.org/publications/preprint/38w1"&gt;paper about the rotation number&lt;/a&gt; for the 
&lt;a href="https://cicm-conference.org/2021/"&gt;CICM 2021&lt;/a&gt; conference on intelligent computer
mathematics. &lt;/p&gt;
&lt;p&gt;Rotation number is the key numerical invariant of an orientation
preserving circle homeomorphism.  Circle self-maps $f : S^1 → S^1$, 
$S^1 = ℝ/ℤ$, constitute an important class of dynamical systems. They
appear in applications, e.g., as Poincaré maps of continuous flows on
the $2$-torus.  The simplest circle self-maps are pure rotations 
$x ↦ x + a$. It turns out that any circle homeomorphism f is semiconjugate 
to a pure rotation $x ↦ x + τ(f)$. The number $τ(f)$ is called the
rotation number of $f$.&lt;/p&gt;
&lt;p&gt;This paper describes the current state of an ongoing project with aim to
formalize various facts about circle dynamics in Lean. Currently, the
formalized material includes the definition and basic properties of the
translation number of a lift of a circle homeomorphism to the real line.
Yury Kudryashov also formalized a theorem by Étienne Ghys that gives a
necessary and sufficient condition for two actions of a group on the
circle by homeomorphism to be semiconjugate to each other.&lt;/p&gt;&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/yury-kudryashovs-rotation-number-paper/</guid><pubDate>Sun, 19 Sep 2021 16:46:20 GMT</pubDate></item></channel></rss>