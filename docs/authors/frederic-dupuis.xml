<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lean community blog (Posts by Frédéric Dupuis)</title><link>https://leanprover-community.github.io/blog/</link><description></description><atom:link href="https://leanprover-community.github.io/blog/authors/frederic-dupuis.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2022 &lt;a href="mailto:"&gt;The Lean prover community&lt;/a&gt; </copyright><lastBuildDate>Tue, 04 Jan 2022 22:20:37 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Semilinear maps</title><link>https://leanprover-community.github.io/blog/posts/semilinear-maps/</link><dc:creator>Frédéric Dupuis</dc:creator><description>&lt;p&gt;Since linear maps appear everywhere in mathematics, it comes as no surprise that they have been part of mathlib for quite some time. However, as we were working on adding the basics of functional analysis to mathlib, a drawback quickly became apparent: conjugate-linear maps could not directly be expressed as linear maps. This meant that some constructions could not be formulated in their most natural way: for example, the map that takes an operator to its adjoint on a complex Hilbert space is a conjugate linear map, and so is the Riesz representation that maps a vector to its dual. This was also preventing us from developing the orthogonal group, the unitary group, etc, properly.&lt;/p&gt;
&lt;p&gt;A few options were considered to introduce conjugate-linear maps. One possible way was to define the &lt;a href="https://en.wikipedia.org/wiki/Complex_conjugate_vector_space"&gt;conjugate space&lt;/a&gt; of &lt;code&gt;E&lt;/code&gt; as a type copy where scalar multiplication is conjugated. Then, a conjugate-linear maps is a standard linear map to the conjugate space. This would have enabled us to reuse the API of linear maps without having too much to refactor, but an early attempt to do this was abandoned when converting between the conjugate space and the original space proved to be unwieldy. A further disadvantage is that the type copy would have also appeared in the real case for constructions involving &lt;code&gt;is_R_or_C&lt;/code&gt;. Another potential solution to the problem was to define conjugate-linear maps separately from linear maps. The big drawback here is that the API for linear maps would effectively have to be duplicated for those new maps.&lt;/p&gt;
&lt;p&gt;This left the more arduous option, namely to redefine &lt;code&gt;linear_map&lt;/code&gt; to also include semilinear maps. A semilinear map &lt;code&gt;f&lt;/code&gt; is a map from an &lt;code&gt;R&lt;/code&gt;-module to an &lt;code&gt;S&lt;/code&gt;-module with a ring homomorphism &lt;code&gt;σ&lt;/code&gt; between &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;, such that &lt;code&gt;f (c • x) = (σ c) • (f x)&lt;/code&gt;. If we plug in the identity into &lt;code&gt;σ&lt;/code&gt;, we get regular linear maps, and if we plug in the complex conjugate, we get conjugate linear maps. There are also other examples (e.g. Frobenius-linear maps) where this is useful which are covered by this general formulation. This implied a major refactor: we had to replace the basic definition of &lt;code&gt;R&lt;/code&gt;-linear maps &lt;code&gt;E →ₗ[R] F&lt;/code&gt; by &lt;code&gt;σ&lt;/code&gt;-semilinear maps &lt;code&gt;E →ₛₗ[σ] F&lt;/code&gt; while keeping the original notation for plain linear maps, and deal with the various problems that this inevitably created further down the import tree. The same also had to be done for linear equivalences, continuous linear maps/equivalences, and linear isometries. This idea had first been proposed by Yury Kudryashov &lt;a href="https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214442983"&gt;about a year ago&lt;/a&gt;, but it then took several months to build up the motivation to embark on this project. Last July, Heather Macbeth, Rob Lewis and I finally managed to start working on it, and the result was &lt;a href="https://github.com/leanprover-community/mathlib/pull/9272"&gt;merged&lt;/a&gt; into mathlib in late September.&lt;/p&gt;
&lt;p&gt;The main issue that we had to overcome involved composition of semilinear maps, and &lt;code&gt;symm&lt;/code&gt; for linear equivalences. Suppose we have &lt;code&gt;f : E₁ →ₛₗ[σ₁₂] E₂&lt;/code&gt; and &lt;code&gt;g : E₂ →ₛₗ[σ₂₃] E₃&lt;/code&gt;, we would naturally end up with &lt;code&gt;g.comp f : E₁ →ₛₗ[σ₂₃.comp σ₁₂] E₃&lt;/code&gt;. However, in most cases of interest, this is very awkward: suppose, for example, that we have defined the adjoint as a conjugate-linear map: &lt;code&gt;adjoint : (E →ₗ[ℂ] F) →ₛₗ[conj] (F →ₗ[ℂ] E)&lt;/code&gt;, and want to express the fact that the adjoint of the adjoint is the identity; in other words, we want a lemma like&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://leanprover-community.github.io/blog/posts/semilinear-maps/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;lemma adjoint_adjoint : adjoint.comp adjoint = (id : E →ₗ[ℂ] F)
&lt;/pre&gt;
&lt;p&gt;However, the general composition lemma for semilinear maps wouldn't give us this: the &lt;code&gt;id&lt;/code&gt; on the right-hand side would actually be of type &lt;code&gt;E →ₛₗ[conj.comp conj] F&lt;/code&gt;! A similar problem arises for &lt;code&gt;symm&lt;/code&gt; for a semilinear equivalence. Suppose we have a semilinear equivalence &lt;code&gt;e : E ≃ₛₗ[σ] F&lt;/code&gt;, then &lt;code&gt;e.symm&lt;/code&gt; will naturally be of type &lt;code&gt;F ≃ₛₗ[σ.symm] E&lt;/code&gt;. Again this is undesirable in interesting cases: suppose we have defined the Riesz representation of a vector (i.e. the map that takes a vector &lt;code&gt;v : E&lt;/code&gt; to its dual &lt;code&gt;λ x, ⟪v, x⟫&lt;/code&gt; in a Hilbert space) as a conjugate-linear equivalence &lt;code&gt;to_dual : E ≃ₛₗ[conj] (dual E)&lt;/code&gt;. Then, of course we want &lt;code&gt;to_dual.symm&lt;/code&gt; to be of type &lt;code&gt;(dual E) ≃ₛₗ[conj] E&lt;/code&gt;, but the general lemma regarding &lt;code&gt;symm&lt;/code&gt; will yield a map of type &lt;code&gt;(dual E) ≃ₛₗ[conj.symm] E&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To solve these two issues, we created two typeclasses to make Lean infer the right ring homomorphism. The first one is &lt;code&gt;[ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃]&lt;/code&gt; which expresses the fact that &lt;code&gt;σ₂₃.comp σ₁₂ = σ₁₃&lt;/code&gt;, and the second one is &lt;code&gt;[ring_hom_inv_pair σ₁₂ σ₂₁]&lt;/code&gt; which states that &lt;code&gt;σ₁₂&lt;/code&gt; and &lt;code&gt;σ₂₁&lt;/code&gt; are inverses of each other. The ring homomorphism &lt;code&gt;σ₁₃&lt;/code&gt; (resp. &lt;code&gt;σ₂₁&lt;/code&gt;) is inferred silently by the typeclass system using &lt;code&gt;out_param&lt;/code&gt;. Then, to make our two examples go through properly, we just need to add instances for &lt;code&gt;ring_hom_comp_triple conj conj id&lt;/code&gt; and &lt;code&gt;ring_hom_inv_pair conj conj&lt;/code&gt;. There is also a third typeclass &lt;code&gt;[ring_hom_surjective σ]&lt;/code&gt;, which is a necessary assumption to generalize some basic lemmas.&lt;/p&gt;
&lt;p&gt;This refactor is now mostly complete ("mostly" because there are still lots of lemmas left to generalize!), and we have also &lt;a href="https://github.com/leanprover-community/mathlib/pull/9875"&gt;added notation&lt;/a&gt; specifically for conjugate-linear maps: &lt;code&gt;E →ₗ⋆[ℂ] F&lt;/code&gt; denotes conjugate-linear maps from &lt;code&gt;E&lt;/code&gt; to &lt;code&gt;F&lt;/code&gt;. Such maps are now slowly starting to appear, with the Riesz representation in &lt;a href="https://github.com/leanprover-community/mathlib/pull/9924"&gt;PR #9924&lt;/a&gt;, and the adjoint coming soon!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;The examples given here have been simplified to get to the core of the issue; in reality, these maps would involve &lt;em&gt;continuous&lt;/em&gt; linear maps, we would most likely have to specify the type of &lt;code&gt;adjoint&lt;/code&gt; for Lean to infer the correct types, etc. &lt;a class="footnote-backref" href="https://leanprover-community.github.io/blog/posts/semilinear-maps/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><guid>https://leanprover-community.github.io/blog/posts/semilinear-maps/</guid><pubDate>Sat, 11 Dec 2021 11:00:00 GMT</pubDate></item></channel></rss>